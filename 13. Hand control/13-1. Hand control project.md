# PBL 실습형 교재 문서 (PC–Pico 연동형)

## 1. 실습 주제

**Mediapipe 손끝 추적으로 서보모터 각도 원격 제어하기**

# 2. 프로젝트 개요

PC에서 웹캠으로 손 검지를 추적하여 **손끝의 가로 위치**를 ([-1,1]) 범위의 값으로 변환해 MQTT로 발행합니다.
Pico는 해당 값을 받아 **서보모터 각도(0°~180°)** 로 매핑하여 실시간으로 회전시킵니다.

* **PC (OpenCV + MediaPipe + Paho-MQTT)**: 손끝 추적 → 정규화 → 주기적 퍼블리시
* **Pico (MQTT + ServoMotor)**: 메시지 수신 → 범위 제한 → 각도 변환 → 서보 구동

## 3. 선행 작업

(여기에 PC용 Python 패키지 설치, 카메라/드라이버 확인, Pico 네트워크 연결 사전 설정 등을 적어 넣으세요.)

📸 (여기에 하드웨어 연결 사진/개요도 첨부)

## 4. 개념 설명

* **손끝 위치 정규화**
  MediaPipe Hands가 반환하는 검지 끝 랜드마크(보통 `landmark[8]`)의 x좌표는 카메라 프레임 폭 기준 **0.0~1.0**입니다. 이를 좌우 중심 기준 ([-1,1])로 바꾸기 위해
  [
  v = \mathrm{clip}(2\cdot x_{\text{norm}} - 1,\ -1,\ 1)
  ]
  형태로 변환합니다. 왼쪽은 -1, 중앙은 0, 오른쪽은 1에 대응합니다.

* **서보 각도 매핑**
  수신한 (v\in[-1,1])를 각도로 바꿉니다:
  [
  \theta = 90 + 90\cdot v \quad(\Rightarrow\ 0^\circ \sim 180^\circ)
  ]
  즉, 중앙(0)은 90°, 좌(-1)은 0°, 우(1)은 180°가 됩니다. 각도는 안전을 위해 0~180 범위로 클램프합니다.

* **전송 주기 조절(디바운싱/스로틀링)**
  너무 자주 전송하면 네트워크/디바이스가 바빠집니다. PC 측은 **약 33Hz(0.03s 간격)** 로 퍼블리시하여 부하를 줄입니다.

## 5. Pico 코드

```python
from ticle import WifiManager
from umqtt.simple2 import MQTTClient
from ticle.ext import ServoMotor
import utime

TOPIC=b"ticle/servo/x"

wifi=WifiManager()
wifi.connect("HBE_RSP","hanback91!")

servo_pin=2
servo=ServoMotor([servo_pin])
servo.angle=90

def clamp(v,a,b):
    return a if v<a else b if v>b else v

def on_msg(t,msg,ret,dup):
    try:
        x=float(msg)
    except:
        return
    x=clamp(x,-1.0,1.0)
    ang=int(round(90+90*x))
    if ang<0: ang=0
    if ang>180: ang=180
    servo.angle=ang

c=MQTTClient("pico_servo","test.mosquitto.org",port=1883)
c.set_callback(on_msg)
c.connect()
c.subscribe(TOPIC)

while True:
    c.check_msg()
    utime.sleep_ms(10)
```

## 6. PC 코드

```python
import cv2, time
import mediapipe as mp
import paho.mqtt.client as mqtt

BROKER="test.mosquitto.org"; PORT=1883; TOPIC="ticle/servo/x"

client=mqtt.Client(client_id="pc_mediapipe_publisher")
client.connect(BROKER, PORT, 60); client.loop_start()

mp_hands=mp.solutions.hands
hands=mp_hands.Hands(static_image_mode=False, max_num_hands=1, min_detection_confidence=0.5, min_tracking_confidence=0.5)

cap=cv2.VideoCapture(0)
last_pub=0
while True:
    ok,frame=cap.read()
    if not ok: break
    rgb=cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    res=hands.process(rgb)

    x_norm=None
    if res.multi_hand_landmarks:
        lm=res.multi_hand_landmarks[0].landmark
        x_norm=lm[8].x
        v=float(max(-1.0, min(1.0, x_norm*2.0-1.0)))
        now=time.time()
        if now-last_pub>0.03:
            client.publish(TOPIC, str(v).encode(), qos=0, retain=False)
            last_pub=now
        cv2.putText(frame, f"x:{x_norm:.2f} -> {v:.2f}", (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,0), 2)

    cv2.imshow("hand", frame)
    if cv2.waitKey(1)&0xFF==ord('q'): break

cap.release()
hands.close()
client.loop_stop()
client.disconnect()
cv2.destroyAllWindows()
```

## 7. 코드 요약 (PC / Pico 분리)

### PC 코드 요약

1. **웹캠 → 손 검지 끝 좌표**

```python
mp_hands=mp.solutions.hands
hands=mp_hands.Hands(...)
res=hands.process(rgb)
x_norm = res.multi_hand_landmarks[0].landmark[8].x
```

* 실시간 프레임을 MediaPipe Hands에 넣어 **검지 끝 점(8번)** 의 x를 0~1로 획득합니다.

2. **정규화 및 전송**

```python
v = max(-1.0, min(1.0, x_norm*2.0-1.0))
if time.time()-last_pub > 0.03:
    client.publish(TOPIC, str(v).encode(), qos=0, retain=False)
```

* (v=2x-1) 로 좌우 중심 기준 ([-1,1]) 범위로 변환하고, 33Hz 이내로 전송합니다.
* 프레임에 `x`와 `v`를 오버레이하여 디버깅에 활용합니다.

3. **리소스 정리**

* 종료 시 카메라/MediaPipe/MQTT 루프를 정리해 안전 종료합니다.

### Pico 코드 요약

1. **네트워크 & MQTT 구독**

```python
wifi.connect("SSID","PWD")
c=MQTTClient("pico_servo","test.mosquitto.org",port=1883)
c.set_callback(on_msg); c.connect(); c.subscribe(TOPIC)
```

* 브로커 `test.mosquitto.org`, 토픽 `ticle/servo/x` 를 구독합니다.

2. **메시지 처리 → 각도 변환**

```python
x=clamp(float(msg), -1.0, 1.0)
ang=int(round(90+90*x))  # 0~180
servo.angle=ang
```

* ([-1,1]) → ([0,180]) 매핑(중앙은 90°), 범위를 넘으면 클램프합니다.

3. **폴링 루프**

```python
while True:
    c.check_msg()
    utime.sleep_ms(10)
```

* 짧은 슬립으로 CPU 점유를 낮추며 메시지를 지속 확인합니다.

## 8. 결과 확인

* 화면에 손을 비치고 **검지 끝을 좌우로 움직이면**, 서보모터가 **좌(0°)–중앙(90°)–우(180°)** 범위로 따라 움직입니다.
* PC 화면 좌측 상단 텍스트(`x:… -> v:…`)가 현재 전송값을 보여주며, 서보 각도와 일치하는지 확인합니다.

📸 (여기에 동작 장면 스크린샷 / 서보 각도 변화 사진 첨부)


## 9. 연습문제

1. **민감도 조정**: 전송 주기를 0.02s/0.05s로 바꾸어 반응성과 부하를 비교하세요.
2. **중앙 데드존**: (|v|<0.05) 구간에서 90° 고정되도록 데드존을 추가해 보세요.
3. **양손 제어 확장**: 왼손 x는 서보1, 오른손 x는 서보2로 매핑하도록 PC 코드를 확장해 보세요.
