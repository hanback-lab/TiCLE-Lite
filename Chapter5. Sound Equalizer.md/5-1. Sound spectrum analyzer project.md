# Sound spectrum analyzer

## 1. 실습 주제

마이크로 입력된 소리를 주파수별로 분석해, 16×16 LED 매트릭스에 스펙트럼 형태로 시각화하기

## 2. 프로젝트 개요

이 실습은 **“소리의 주파수 분포를 눈으로 확인”** 하는 프로젝트입니다.
마이크로 들어온 아날로그 신호를 **ADC로 샘플링한 뒤**,
각 주파수 구간의 세기를 **Goertzel 알고리즘**으로 계산합니다.
그 결과를 16개의 열로 나타내어, **저음~고음**까지의 에너지를 시각적으로 표시합니다.

## 3. 개념 설명

### (1) 왜 주파수로 바꾸는가

마이크가 수집한 신호는 시간에 따라 진동하는 전압, 즉 **시간 영역(Time Domain)** 신호입니다.
이 신호를 그대로 보면 “파형”은 알 수 있지만, **어떤 음이 섞여 있는지(주파수 성분)** 는 알 수 없습니다.
그래서 이를 **주파수 영역(Frequency Domain)** 으로 바꾸는 과정이 필요합니다.
즉, “시간에 따라 변하는 소리”를 “각 주파수마다 얼마나 강한지”로 바꾸는 것입니다.

### (2) DFT와 FFT, Goertzel의 차이

* **DFT (Discrete Fourier Transform)**
  신호 (x[n])을 여러 주파수 성분 (X[k])으로 바꿉니다.
  
  $$X[k] = \sum_{n=0}^{N-1} x[n] , e^{-j2\pi kn/N}$$

  각 (k)는 주파수 성분(Hz)에 대응하며, 실수부·허수부를 통해 진폭과 위상을 얻습니다.

* **FFT (Fast Fourier Transform)**
  DFT의 모든 주파수 성분을 한 번에 빠르게 계산하는 알고리즘입니다.
  하지만 메모리와 연산량이 커서 Pico 같은 보드에서는 부담이 큽니다.

* **Goertzel 알고리즘**
  DFT의 원리를 간소화해, 특정 주파수의 (X[k])만 계산합니다.
  전체 FFT를 구하지 않아도 되므로 훨씬 가볍습니다.
  본 실습에서는 **16개의 중심 주파수(80~900Hz)** 에 대해 Goertzel 연산을 반복하여
  각 구간의 에너지를 얻습니다.

## 4. 코드 전체

```python
from machine import ADC
import utime, math
from ticle.ext import WS2812Matrix

MIC_ADC = 26
MATRIX_W = 16
MATRIX_H = 16
SAMPLE_RATE = 8000
FRAME_SAMPLES = 128
FREQ_MIN = 80.0
FREQ_MAX = 900.0
BRIGHT = 0.22

adc = ADC(MIC_ADC)
matrix = WS2812Matrix([(3,1)])
CENTER = 32768
SAMPLE_INTERVAL_US = int(1_000_000 / SAMPLE_RATE)

def logspace(a, b, n):
    la, lb = math.log(a), math.log(b)
    step = (lb - la) / (n - 1)
    return [math.exp(la + i * step) for i in range(n)]

def color_from_level(t):
    if t < 0: t = 0.0
    if t > 1: t = 1.0
    if t < 0.5:
        r = int(2 * t * 255); g = 255
    else:
        r = 255; g = int(2 * (1.0 - t) * 255)
    return (int(r * BRIGHT), int(g * BRIGHT), 0)

def set_pixel(x, y, rgb):
    if x < 0 or x >= MATRIX_W or y < 0 or y >= MATRIX_H:
        return
    matrix[[x, y]] = rgb

def draw_col(col, height):
    for y in range(MATRIX_H):
        set_pixel(col, y, (0, 0, 0))
    for i in range(height):
        y = MATRIX_H - 1 - i
        t = (i + 1) / MATRIX_H
        set_pixel(col, y, color_from_level(t))

band_freqs = logspace(FREQ_MIN, FREQ_MAX, MATRIX_W)

def goertzel_power(samples, freq, fs, n):
    k = int(0.5 + (n * freq) / fs)
    w = (2 * math.pi / n) * k
    cosw = math.cos(w)
    coeff = 2 * cosw
    s0 = s1 = s2 = 0.0
    for x in samples:
        s0 = x + coeff * s1 - s2
        s2, s1 = s1, s0
    power = s1 * s1 + s2 * s2 - coeff * s1 * s2
    return power / (n * n)

def read_frame(n):
    buf = [0.0] * n
    t_next = utime.ticks_us()
    for i in range(n):
        t_next += SAMPLE_INTERVAL_US
        raw = adc.read_u16()
        buf[i] = (raw - CENTER) / 32768.0
        while utime.ticks_diff(utime.ticks_us(), t_next) < 0:
            pass
    m = sum(buf) / n
    for i in range(n):
        buf[i] -= m
    return buf

def main():
    matrix.clear(); matrix.update(); utime.sleep_ms(50)
    while True:
        frame = read_frame(FRAME_SAMPLES)
        powers = [goertzel_power(frame, f, SAMPLE_RATE, FRAME_SAMPLES) for f in band_freqs]
        mx = max(1e-9, max(powers))
        for x, p in enumerate(powers):
            t = p / mx
            h = int(t * MATRIX_H)
            if h > MATRIX_H: h = MATRIX_H
            draw_col(x, h)
        matrix.update()

if __name__ == '__main__':
    try:
        main()
    finally:
        matrix.clear(); matrix.update()
```

---

## 5. 코드 요약

### (1) 마이크 신호 샘플링 – `read_frame()`

```python
def read_frame(n):
    buf = [0.0] * n
    for i in range(n):
        raw = adc.read_u16()
        buf[i] = (raw - CENTER) / 32768.0
    m = sum(buf)/n
    for i in range(n):
        buf[i] -= m
    return buf
```

이 함수는 아날로그 입력(마이크 전압)을 **디지털로 일정 간격마다 읽어** `n`개의 샘플 배열을 만듭니다.
또한 평균값(`m`)을 빼서 **DC 성분(직류 오프셋)** 을 제거합니다.
이 과정은 주파수 변환 전에 필수로 수행되는 **신호 전처리 단계**입니다.

---

### (2) 주파수 구간 설정 – `logspace()`

```python
band_freqs = logspace(FREQ_MIN, FREQ_MAX, MATRIX_W)
```

이 함수는 80Hz~900Hz 범위를 **로그 스케일**로 16개로 나누어 각 주파수 구간을 정합니다.
로그 분포를 사용하는 이유는 인간의 귀가 **저주파에는 민감하고, 고주파에는 둔감하기 때문**입니다.
즉, 사람의 청감과 비슷한 간격으로 스펙트럼을 구성합니다.

---

### (3) 주파수 분석 – `goertzel_power()`

```python
def goertzel_power(samples, freq, fs, n):
    k = int(0.5 + (n * freq) / fs)
    w = (2 * math.pi / n) * k
    ...
```

이 부분이 핵심입니다.
DFT의 수식 중 특정 (k) 성분만 구하는 식을 변형한 것으로,
아래와 같은 재귀식으로 계산됩니다.


$$s[n] = x[n] + 2\cos(w) s[n-1] - s[n-2]$$


최종적으로 계산된 (s_1, s_2)를 통해 해당 주파수 성분의 에너지를 얻습니다.

$$P = s_1^2 + s_2^2 - 2\cos(w)s_1 s_2$$


이 값이 바로 **“이 주파수 구간에서 소리가 얼마나 강한가”** 를 의미합니다.
이 과정을 주파수별로 반복해 전체 스펙트럼을 만듭니다.

---

### (4) 정규화 및 막대 높이 변환

```python
powers = [goertzel_power(frame, f, SAMPLE_RATE, FRAME_SAMPLES) for f in band_freqs]
mx = max(1e-9, max(powers))
for x, p in enumerate(powers):
    t = p / mx
    h = int(t * MATRIX_H)
    draw_col(x, h)
```

주파수별 에너지를 구한 후, 프레임 내에서 가장 큰 값을 기준으로 **0~1 사이로 정규화**합니다.
이렇게 하면 소리 크기(전체 볼륨)가 달라져도 상대적인 패턴이 유지됩니다.
`h`는 각 막대의 높이로 변환되어 LED 행 개수로 표현됩니다.

### (5) 시각화 – `draw_col()`과 `color_from_level()`

```python
def color_from_level(t):
    if t < 0.5:
        r = int(2 * t * 255); g = 255
    else:
        r = 255; g = int(2 * (1.0 - t) * 255)
```

세기가 낮을수록 초록색, 강할수록 빨강에 가까워집니다.
이로써 “저음은 약하게, 큰 소리는 밝게” 시각적으로 표현됩니다.
매 프레임마다 `matrix.update()`를 호출해 즉시 LED에 반영합니다.

## 6. 결과 확인

소리를 내면 16개의 열이 각각 진동하면서 반응합니다.
저음(왼쪽)은 베이스나 드럼, 고음(오른쪽)은 박수나 휘파람 소리에 강하게 반응합니다.
유튜브에 100hz, 900hz 와 같이 특정 주파수를 출력하는 영상을 재생하여 TiCLE의 Mic에 가져다 대면, 주파수를 잘 감지하는 것을 확인할 수 있습니다.

## 7. 연습문제

1. `color_from_level()` 함수를 수정해 **파란색~보라색** 계열로 색상을 바꿔보세요.
2. `BRIGHT` 값을 0.1~0.5로 바꿔 전체 밝기 차이를 비교해보세요.
3. `y = MATRIX_H - 1 - i`를 `y = i`로 바꿔, 막대가 **위에서 아래로 자라는 형태**로 변경해보세요.
