# 고급 제어

## irq

irq란 인터럽트 요청(Interrupt Request)을 말하며, 임의로 설정한 특정 조건을 달성하였을 때 메인 CPU에 인터럽트를 발생시켜 특정 작업을 수행시키도록 합니다. irq를 사용했을 때의 장점은 바로 메인 함수의 부담을 덜어주는 것입니다. 예를 들어 Switch의 입력을 감지해 LED에 불을 켠다고 가정했을 때, 일반적으로 다음과 같은 코드를 구상합니다.

참고로 `sw_pin` 변수는 스위치와 연결된 GPIO 핀, `led_pin`은 LED를 제어하는 GPIO 핀 변수입니다.

```python
...

while True:
    if sw_pin.value == 1:
        led_pin.on()
    else:
        led_pin.off()
    utime.sleep_ms(10)

...
```

이 코드 같은 경우 10 ms 마다 스위치의 입력값을 확인하여, 이 입력 값에 따라 led를 제어합니다. 하지만 이 코드의 경우 버튼의 입력을 **실시간** 으로 감지하고 제어할 수 없습니다. 물론 10ms 또한 빠르다고 볼 수 있습니다. 하지만 일반 전기 신호 속도(초속 150,000~299,999 km/s)를 생각하자면 입력 받은 전기신호가 도착하는 그 즉시 로직을 실행한다고 볼 수 없습니다. 또한, 메인 무한 루프 코드를 건드리는 것에 부담감이 존재합니다. 그리고 언제 들어올 지 모르는 비선형적인 입력값을 받기 위해 10ms 동안 로직을 반복시키는 것도 성능 저하라고 볼 수 있습니다.

irq는 이 상황에서 아주 탁월한 효과를 발휘할 수 있습니다. 스위치의 입력을 irq에다 맡기고, switch의 입력 값에 따라 led를 제어하는 callback 함수를 지정시켜 둡니다. 그리고 switch의 입력 값이 변할 때마다 인터럽트를 발생시키라고 지시해주면, 메인 무한 루프에서는 아무런 로직도 짤 필요가 없습니다. 그리고 irq는 전기 신호를 입력 받은 그 즉시 인터럽트를 발생시켜 cpu한테 알려주기에 비선형적으로 들어오는 입력을 효율적으로 처리해줄 수 있습니다. 

Micropython에서는 `Pin` 클래스의 멤버 변수 `irq()` 를 통해 callback 함수를 지정하고 irq를 지정합니다.

아래 예제는 위 코드를 irq를 사용하여 개선한 코드입니다.

```python
```


`irq`에 관련된 더 자세한 내용은 다음 링크를 참조해주세요.

- https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin.irq

## timer

하드웨어 타이머는 지정는 peroid(또는 일정 시간 지연 후)로 콜백을 실행하는 기본 동작을 정의합니다. 이 기능을 이용해서 '몇 초 후 ~ 활동 실행` 과 같은 수행을 실행할 수 있습니다. 하드웨어 타이머는 상술한 irq와 같이 지정된 시간이 지난 후 인터럽트를 발생시키며, 지정된 callback 함수를 실행시킵니다. 

타이머는 특정 시간마다 주기적으로 계속 반복 실행시키거나 딱 한번만 실행시켜줄 수 있습니다.

Micropython에서는 `machine` 라이브러리의 `Timer` 클래스를 이용해 타이머를 사용할 수 있습니다.

아래 예제는 타이머를 사용해 WS2812의 그림이 1초마다 전환되는 예제입니다.

```python
```

`Timer` 클래스와 관련된 더 자세한 내용은 다음 링크를 참조하여 주십시오.

- https://docs.micropython.org/en/latest/library/machine.Timer.html

## thread

운영체제는 스케줄링을 통해 여러 프로그램을 동시에 실행할 수 있습니다. 초기 스케줄링의 기본 단위는 프로세스였습니다.

유닉스나 리눅스에서는 fork()라는 API를 통해 현재 프로세스를 복제하여 새로운 프로세스를 만들 수 있습니다. 이렇게 만들어진 프로세스의 원본을 부모 프로세스, 복제된 프로세스를 자식 프로세스라고 합니다.

이 방식으로 여러 프로세스를 다루는 멀티 프로세스 프로그래밍도 가능했는데, 문제는 복제된 프로세스가 사용하지 않는 메모리가 발생하여 메모리가 낭비되는 문제가 있었습니다. 게다가 운영체제에서는 메모리 보호 정책 때문에, 각 프로세스는 고유한 가상 메모리 공간에서 실행됩니다. 따라서 프로세스끼리 데이터를 공유하려면 운영체제의 도움 없이는 자원 공유가 불가능했습니다.

이러한 문제를 해결하기 위해 프로세스를 통째로 복제하는 것이 아닌 필요한 특정 부분(함수)만 스케줄링하는 새로운 방법을 고안하여 스레드가 탄생하게 됩니다. 지금은 프로그램을 실행하면 부모 프로세스와 메인 스레드가 생성되고 특정 작업을 스레드로 분리하여 동시에 실행하는 멀티 스레드 방식도 지원됩니다.

스레드는 각각 고유한 스택을 가지고 있지만, 힙, 전역 변수, 함수 같은 프로세스 자원은 서로 공유할 수 있습니다. 단, 자원을 공유하여 사용하게 되어 동시에 같은 자원에 접근하게 되는 경우에는 충돌이 생길 수 있습니다. 이는 동기화를 통해 해결할 수 있습니다.

파이썬 인터프리터는 멀티 스레드 환경에서 객체에 대한 참조 카운터 관리 문제를 해결하기 위해 GIL(Global Interpreter Lock)을 사용합니다. 파이썬의 메모리 관리 시스템은 객체가 만들어진 후 참조 카운터를 통해 관리됩니다.

파이썬 메인 모듈은 기본적으로 하나의 스레드 환경에서 실행되며, 이를 메인 스레드라고 합니다. 

Micropython에서는 `_thread` 모듈을 통해 스레드를 사용할 수 있습니다.

다음 예제는 한 개의 무한 루프가 메인 스레드로, 두 개의 무한 루프 함수가 스레드로 실행되는 예제입니다.

```python
import _thread
import utime

def core0_task():
    while True:
        print("Core 0: Running task...")
        utime.sleep_ms(1000)

def core1_task():
    while True:
        print("Core 1: Doing something else...")
        utime.sleep_ms(500)

_thread.start_new_thread(core0_task, ())
_thread.start_new_thread(core1_task, ())

while True:
    print("Main program: Still active...")
    time.sleep(2)
```

`_thread` 모듈에 관해 더 자세한 사용법은 아래 링크를 참조하여 주십시오.

- https://docs.micropython.org/en/latest/library/_thread.html

## asyncio
asyncio는 파이썬에서 비동기 I/O 처리하기 위한 표준 라이브러리 모듈입니다. 복잡한 스레드나 프로세스 없이도, 단일 스레드 내에서 수많은 네트워크 요청, 타이머 웹소켓 과 같은 작업들을 효율적으로 동시 실행할 수 있게 해줍니다. 

### asyncio 작동 원리 
asyncio는 이벤트 루프 기반으로 동작합니다. 하나의 이벤트 루프가 있으며, async def로 정의된 코루틴(coroutine) 들이 등록됩니다. await 키워드를 통해 작업중인 비동기 작업을 일시 중단하고 대기중인 다른 작업을 수행할 수 있게 합니다. 

### 주요 구성 요소 
- async def : 비동기 함수 정의, 코루틴 객체를 생성 
- await : 코루틴 실행 중 일시 중단, 호출 시 다른 작업에 CPU 양보 
- asyncio.run() : 이벤트 루프 생성 및 코루틴 실행 
- asyncio.create_task() : 여러 코루틴을 통시에 실행하는 태스크 
- asyncio.sleep() : 비동기 타이머, 논블로킹(non-blocking) 방식으로 실행
    - time.sleep() 을 사용하면 블로킹 상태가 되어 비동기 처리와는 맞지 않음! 

## 동기방식과 비동기 방식의 차이 
예를 들어 A,B,C 라는 작업을 수행하는데, 작업에 수행되는 시간이 A는 5초, B는 10초, C 는 15초 가 걸린다고 가정해보겠습니다. 이를 순차적으로 처리하면 총 30초가 소요됩니다. 하지만 작업을 순차적으로 처리하는 것이 아닌 비동기 방식으로 처리하면 약 15초 만에 처리가 가능합니다. 

![sync & async](res/sync&async.png)

동기 방식과 비동기 방식을 요약해서 정리하면 다음과 같이 정리할 수 있습니다. 

| 항목 | 동기 방식 | 비동기 방식 |
|:-------|:------|:------|
| 실행 방식 | 순차 실행 | 동시 실행 | 
| 총 작업 시간 | 모든 작업 시간 누적 | 가장 긴 작업 시간에 수렴 | 
| 사용 예시 | DB 트랜잭션, 시리얼 처리 등 | 센서 데이터 수집, 네트워크 요청 등 | 

### 동기 방식 예시 
```python
import utime

def task_sync(name, duration):
    print(f"{name} start")
    utime.sleep_ms(duration)
    print(f"{name} done")

def run_sync_tasks():
    start = utime.time()
    task_sync("A", 5000)
    task_sync("B", 10000)
    task_sync("C", 15000)
    end = utime.time()
    print(f"Total time : {end - start:.2f}초")

if __name__ == "__main__":
    run_sync_tasks()
```

### 비동기 방식 예시 
```python
import asyncio
import utime

async def task_async(name, duration):
    print(f"{name} start")
    await asyncio.sleep(duration)
    print(f"{name} done")

async def run_async_tasks():
    start = utime.time()
    await asyncio.gather(
        task_async("A", 5),
        task_async("B", 10),
        task_async("C", 15)
    )
    end = utime.time()
    print(f"Total time : {end - start:.2f}초")

if __name__ == "__main__":
    asyncio.run(run_async_tasks())
```
