# PBL 실습형 교재 문서 (PC–Pico 연동형)

## 1. 실습 주제

**IR·CdS 센서 텔레메트리 및 원격 LCD 표출: PC–Pico 산업 모니터링 미니 시스템**

---

## 2. 프로젝트 개요

Pico는 **IR 리모컨 코드**와 **조도(CdS) 값**을 주기적으로 전송하고, PC는 이를 GUI로 표시합니다.
또한 PC에서 입력한 문자열을 Pico가 받아 **I²C LCD**에 즉시 표시합니다.
데이터 흐름: **센서 읽기 → 텔레메트리 전송 → PC 표시 / PC 입력 → LCD 표시**.

---

## 3. 선행 작업

(여기에 Pico 펌웨어/패키지 설치, PC용 의존성 설치, MQTT 브로커 접속 테스트 등을 정리하세요.)
📋 체크리스트 칸:

* [ ] Pico 패키지 설치
* [ ] PC Python 가상환경 & 라이브러리
* [ ] 브로커 접속 확인

---

## 4. 개념 설명 (알고리즘 개요)

* **주기적 텔레메트리:** Pico가 일정 간격(200ms)마다 `{"cds":…, "ir_code":…, "protocol":…}` 형태로 상태를 전송합니다.
* **이벤트 수신·표출:** PC는 수신 데이터를 GUI 라벨에 반영합니다.
* **원격 제어 역방향:** PC에서 텍스트를 전송하면 Pico가 LCD를 **지우고** 새 텍스트를 표시합니다.
* **비동기 루프:** 양측 모두 논블로킹 루프로 통신을 주기 처리하여 UI/센싱이 끊기지 않도록 합니다.

---

## 5. Pico 코드

```python
from ticle import WifiManager
from umqtt.simple2 import MQTTClient
from machine import Pin, ADC
from ir_remote import IRReceiver
from hd44780_pcf8574 import HD44780_PCF8574
import ujson, utime

BROKER="test.mosquitto.org"
TOPIC_TX=b"ticle/monitor/telemetry"
TOPIC_RX=b"ticle/monitor/lcd"

wifi=WifiManager()
wifi.connect("HBE_RSP","hanback91!")

ir=IRReceiver(pin=17)
cds=ADC(Pin(27))
lcd=HD44780_PCF8574(scl=9, sda=8)

def on_msg(t,msg,ret,dup):
    s=msg.decode().strip()
    if s:
        lcd.clear()
        lcd.text(s)

c=MQTTClient("pico_monitor",BROKER,port=1883)
c.set_callback(on_msg)
c.connect()
c.subscribe(TOPIC_RX)

last=utime.ticks_ms()
ir_code = None
ir_proto = None

while True:
    c.check_msg()
    v_cds=cds.read_u16()
    frame=ir.read(timeout_ms=200)
    if frame and frame.protocol=="NEC":
        ir_code=frame.command
        ir_proto=frame.protocol
    if utime.ticks_diff(utime.ticks_ms(),last)>=200:
        payload={
            "cds":v_cds,
            "ir_code":ir_code if ir_code is not None else "none",
            "protocol":ir_proto if ir_proto is not None else "none"
        }
        c.publish(TOPIC_TX,ujson.dumps(payload).encode())
        last=utime.ticks_ms()
    utime.sleep_ms(10)
```

---

## 6. PC 코드

```python
import sys, json, time
from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, QGridLayout
from PySide6.QtCore import QObject, Signal, Qt
import paho.mqtt.client as mqtt

BROKER="test.mosquitto.org"
TOPIC_TX="ticle/monitor/lcd"
TOPIC_RX="ticle/monitor/telemetry"

class MqttBridge(QObject):
    telemetry=Signal(dict)
    connected=Signal(bool)
    def __init__(self):
        super().__init__()
        self.cli=mqtt.Client(client_id=f"pc_qt_monitor_{int(time.time())}", clean_session=True)
        self.cli.on_connect=self._on_connect
        self.cli.on_message=self._on_message
        self.cli.connect(BROKER,1883,60)
        self.cli.loop_start()
    def _on_connect(self,client,userdata,flags,rc):
        self.connected.emit(rc==0)
        if rc==0:
            self.cli.subscribe(TOPIC_RX,qos=0)
    def _on_message(self,client,userdata,msg):
        try:
            d=json.loads(msg.payload.decode())
            self.telemetry.emit(d)
        except Exception:
            pass
    def publish_text(self,s:str):
        self.cli.publish(TOPIC_TX,payload=s.encode(),qos=0,retain=False)

class Main(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Industrial Monitor (IR, CdS) • LCD Control")
        self.bridge=MqttBridge()
        self._ui()
        self.bridge.connected.connect(self.on_conn)
        self.bridge.telemetry.connect(self.on_telemetry)
    def _ui(self):
        v=QVBoxLayout(self)
        self.status=QLabel("MQTT: connecting...")
        v.addWidget(self.status)
        g=QGridLayout()
        self.lbl_ir_code=QLabel("-")
        self.lbl_ir_proto=QLabel("-")
        self.lbl_cds=QLabel("-")
        g.addWidget(QLabel("IR Code"),0,0)
        g.addWidget(self.lbl_ir_code,0,1)
        g.addWidget(QLabel("IR Protocol"),1,0)
        g.addWidget(self.lbl_ir_proto,1,1)
        g.addWidget(QLabel("CdS Value"),2,0)
        g.addWidget(self.lbl_cds,2,1)
        v.addLayout(g)
        h=QHBoxLayout()
        self.edit=QLineEdit()
        self.edit.setPlaceholderText("LCD text")
        self.btn=QPushButton("Send to LCD")
        self.btn.clicked.connect(self.on_send)
        h.addWidget(self.edit)
        h.addWidget(self.btn)
        v.addLayout(h)
        self.setLayout(v)
        self.resize(420,240)
    def on_conn(self,ok:bool):
        self.status.setText("MQTT: connected" if ok else "MQTT: failed")
    def on_telemetry(self,d:dict):
        self.lbl_ir_code.setText(str(d.get("ir_code","-")))
        self.lbl_ir_proto.setText(str(d.get("protocol","-")))
        self.lbl_cds.setText(str(d.get("cds","-")))
    def on_send(self):
        s=self.edit.text().strip()
        if s:
            self.bridge.publish_text(s)

if __name__=="__main__":
    app=QApplication(sys.argv)
    w=Main(); w.show()
    sys.exit(app.exec())
```

---

## 7. 코드 요약 (Pico / PC 분리)

### 🧠 Pico 코드 요약

1. **센서 읽기 & IR 디코드**

```python
v_cds=cds.read_u16()
frame=ir.read(timeout_ms=200)
if frame and frame.protocol=="NEC":
    ir_code=frame.command; ir_proto=frame.protocol
```

* CdS는 16비트 ADC 원시값(밝을수록 일반적으로 값 증가).
* IR은 타임아웃 내 수신 프레임이 있고 **NEC** 프로토콜이면 코드만 갱신.

2. **LCD 원격 업데이트 수신**

```python
def on_msg(t,msg,ret,dup):
    s=msg.decode().strip()
    if s: lcd.clear(); lcd.text(s)
```

* PC에서 온 문자열을 바로 LCD에 표시(이전 내용은 `clear()`로 초기화).

3. **주기적 텔레메트리 전송**

```python
if ticks_diff(now,last) >= 200:
    payload={"cds":v_cds,"ir_code":ir_code or "none","protocol":ir_proto or "none"}
    c.publish(TOPIC_TX, dumps(payload).encode())
```

* 200ms 간격으로 센서·IR 상태 패킷 전송.

4. **논블로킹 이벤트 루프**

```python
c.check_msg()
utime.sleep_ms(10)
```

* 수신 콜백 처리 + 짧은 슬립으로 CPU 점유를 낮춤.

---

### 💻 PC 코드 요약

1. **MQTT 브리지 객체화**

```python
self.cli=mqtt.Client(...); self.cli.on_connect=...; self.cli.on_message=...
self.cli.connect(...); self.cli.loop_start()
```

* 연결 완료 시 텔레메트리 토픽을 구독하고, 수신 시 **Signal(dict)** 로 GUI 스레드에 전달.

2. **GUI 바인딩**

```python
self.bridge.connected.connect(self.on_conn)
self.bridge.telemetry.connect(self.on_telemetry)
```

* 연결 상태/수신 데이터가 라벨에 즉시 반영되도록 슬롯에 연결.

3. **LCD 전송 UI**

```python
def on_send(self):
    s=self.edit.text().strip()
    if s: self.bridge.publish_text(s)
```

* 입력창 텍스트를 그대로 전송하면, Pico가 LCD에 반영.

---

## 8. 결과 확인

* PC 앱에 **IR Code / Protocol / CdS Value** 가 실시간으로 갱신됩니다.
* 입력창에 문자를 넣고 “Send to LCD”를 누르면 **Pico LCD**에 즉시 표시됩니다.

📸 **사진/스크린샷 삽입 위치**

* (1) PC GUI 화면 캡처
* (2) Pico LCD 표시 사진
* (3) IR 리모컨 조작 장면
* (4) CdS 조도 변화 실험 사진

---

## 9. 연습문제

1. **형식 지정:** CdS 값을 0–100%로 환산해 표시(선형 스케일링)해 보세요.
2. **알람 임계값:** CdS가 일정 값 이하일 때 PC GUI에 “LOW LIGHT” 경고를 띄워 보세요.
3. **LCD UI 확장:** PC에서 다중 줄 텍스트를 보낼 수 있게 하고, Pico에서 줄바꿈 처리(`\n`)를 지원해 보세요.
