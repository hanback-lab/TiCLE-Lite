# MQTT
MQTT(Message Queue Telemetry Transport)는 앤디 스텐포드-클락(Andy Stanford-Clark)과 알렌 니퍼(Arlen Nipper)가 인공위성을 통해 오일 파이프라인 원격 검침 시스템을 연결하기 위해 1999년부터 설계한 것으로 2010년, 로열티 없는 상태로 출시되어 2014년 표준이 되었습니다. 이후 MQTT V3.1 및 V3.1.1을 중심으로 IoT(Internet of Things) 장치 사이 저전력·저대역폭 환경에 최적화된 경량 메시징 프로토콜 중 하나로 자리매김하고 있으며 2018년 1월 최신 버전인 MQTT V5가 승인된 상태입니다.

MQTT 시스템은 중계 서버 역할을 하는 브로커(broker)와 브로커에 토픽을 기반으로 메시지를 보내고 받는 클라이언트로 구성되는데, 클라이언트는 브로커로부터 토픽 메시지를 구독하는 구독자(subscriber)와 토픽에 메시지를 발행하는 발행자(publisher)로 나누어집니다.

## MQTT 개요 
MQTT는 TCP/IP를 기반으로 한 메시지 버스 시스템으로 클라이언트(발행자, 구독자)와 서버(브로커), 세션, 구독, 토픽으로 구성되며, 게시/구독 모델을 사용하여 메시징을 수행하는 간단한 방법을 제공합니다. 따라서 저전력 센서나 전화기, 내장형 컴퓨터 또는 마이크로 컨트롤러와 같은 모바일 장치를 사용하는 사물 인터넷 메시징에 적합합니다.

![MQTT Architecture](res/MQTT%20Architecture.png)

### MQTT 브로커 
브로커는 TCP 포트 1883을 사용하는 일종의 서버 프로그램으로 발행자와 구독자 사이 중계자 역할만 하므로 서버 대신 브로커란 용어를 사용합니다. 브로커가 발행자로부터 메시지를 수신하면 토픽을 기반으로 이를 게시한 후 토픽에 가입한 모든 구독자에게 배포합니다. 기본적으로 게시된 메시지 중 가입자가 없는 메시지나 배포된 메시지는 제거되지만 보존 속성을 가진 메시지나 영구 세션에서 발행한 메시지는 최소한 다음 배포까지 유지됩니다.

브로커는 IBM MQ와 같은 상용 제품부터 EMQ, mosquitto와 같은 오픈소스에 이르기까지 다양한 제품들이 있는데, 이 중 이클립스 재단에서 배포하는 mosquitto는 MQTT V5.0 프로토콜까지 지원하며, 가볍고 빨라 라즈베리파이와 같은 저전력 단일 보드 컴퓨터부터 서버에 이르기까지 모든 장치에 사용하기 적합합니다.

다음은 운영체제 별로 mosquitto 브로커를 설치하는 방법입니다.

- Linux
```sh 
sudo apt install mosquitto  
```
- Windows 
```sh 
winget install EclipseFoundation.Mosquitto
```
- macOS
```sh
brew install mosquitto 
```

설치가 완료되면 mosquitto는 백그라운드 서비스로 동작하는데, 윈도우에서는 사용자가 작업 관리자의 서비스 탭 또는 서비스 관리자를 실행한 후 mosquitto 항목을 찾아 컨텍스트 메뉴(마우스 우클릭)에서 시작을 선택해야 합니다.
또한 설정 파일인 mosquitto.conf를 편집해 외부 접속 허용, 익명 허용, 보안 로그인과 같은 각종 설정을 변경할 수 있습니다.

- 리눅스: /etc/mosquitto/conf.d/
- 윈도우: mosquitto 설치 폴더

공개용 브로커 간단한 테스트가 목적이라면 브로커를 자신의 컴퓨터에 설치하지 않고 인터넷 클라우드를 통해 무료로 사용할 수 있는 공개용 브로커를 사용해도 됩니다. 특히 공개용 브로커는 인터넷을 통해 언제 어디서든 접속이 가능하므로 사설 IP 환경에서 특히 유용한 선택입니다.

| Name | Broker Address | TCP Port | TLS Port | WebSocket Port| Message Retention |
|:---|:---|:---|:---|:---|:---|
| Eclipse | mqtt.eclipse.org | 1883	| N/A | 80, 443 | YES |
| Mosquitto | test.mosquitto.org | 1883	| 8883, 8884 | 80 | YES |
| HiveMQ | broker.hivemq.com | 1883	| N/A | 8000 | YES |
| Flespi | mqtt.flespi.io | 1883 | 8883 | 80, 443 | YES |
| Dioty	| mqtt.dioty.co | 1883 | 8883 |	8080, 8880 | YES |
| Fluux	| mqtt.fluux.io | 1883 | 8883 | N/A | N/A |
| EMQX | broker.emqx.io | 1883 | 8883| 8083 | YES | 

### MQTT 클라이언트 
해당 장치가 발행자면 토픽에 대한 메시지를 발행해 브로커에 게시할 수 있고 구독자는 특정 토픽을 등록하여 메시지를 수신할 수 있습니다. 하나의 클라이언트는 구독자 또는 발행자이거나 모두일 수 있습니다. 보안 기능을 활성화하면 브로커에 연결할 때 사용자 ID와 비밀번호 또는 인증서를 이용해 인증합니다.

클라이언트는 일반적으로 공개된 MQTT 클라이언트 라이브러리를 이용해 구현하지만 이클립스 재단에서 mosquitto와 함께 제공하는 mosquitto-clients 나 EMQX의 MQTTX 처럼 범용으로 구현된 프로그램들도 있습니다. 특히 MQTTX는 운영체제 별로 GUI 및 CLI을 지원하며, 웹 환경까지 지원해 상황에 맞게 선택할 수 있습니다.

MQTTX 설치 프로그램은 다음 링크를 통해 다운로드 받아 쉽게 설치할 수 있습니다. 
- [MQTTX](https://mqttx.app/downloads)

### 토픽
토픽은 메시지에 대한 발행/구독 패턴의 기준으로 클라이언트 사이 미리 정의한 의미대로 정보를 교환할 수 있게 합니다. 대소 문자를 구분하는 계층 구조의 UTF-8 문자열로 파일 시스템의 경로와 같이 슬래시(/)로 구분되며 발행자와 브로커, 브로커와 구독자 사이 토픽에 따른 메시지 흐름을 구분합니다.

#### 토픽 구조 
$SYS 토픽을 제외하고 기본 또는 표준화된 토픽 구조는 없습니다. $SYS 토픽은 브로커에 대한 정보를 공개하기 위해 대부분의 브로커에서 예약되어 있습니다.

![](res/Topic.png)

앞의 그림의 토픽은 3개의 레벨로 구성되어 있습니다. 첫번째는 Sensor, 두번째는 imu, 세번째는 value 입니다. 

#### 토픽 생성 및 제거 
발행자는 메시지를 발행할 때마다 토픽을 포함하므로 브로커는 토픽이 없으면 만든 후 게시합니다. 또한 구독자도 토픽에 가입할 때 토픽이 없으면 브로커는 만든 후 가입시킵니다. 토픽은 세션이 제거될 때 제거됩니다.

#### 토픽 필터 
발행자가 토픽에 메시지를 게시할 때는 항상 개별적인 발행만 허용하므로 두 가지 토픽에 메시지를 게시하려면 두 번 발행해야 합니다. 하지만 구독자는 여러 토픽에 가입하는 대신 토픽 필터를 적용해 한 번만 가입해도 됩니다. 토픽 필터는 단일 레벨 필터일 '+'와 다중 레벨 필터인 '#' 중 하나를 이용해 레벨 또는 이후 모든 레벨을 와일드카드(wildcard)로 설정합니다.

- +: 단일 레벨 와일드카드로 레벨의 모든 문자 치환
- #: 다중 레벨 와일드카드로 현재 레벨과 이후 모든 레벨의 문자 치환
    - $SYS/#: 브로커의 모든 토픽에 가입

아래와 같은 토픽이 있다고 가정하겠습니다. 

- Sensor/imu/value
- Sensor/ultrasonic/distance
- Sensor/cds/value

이 때 Sensor 하위에서 value로 끝나는 모든 토픽을 구독한다면 다음과 같이 필터를 적용할 수 있습니다. 

- Sensor/+/value

Sensor 하위 모든 토픽을 구독하는 경우에는 다음과 같이 적용합니다. 

- Sensor/# 

### 세션 
세션은 연결된 클라이언트와 브로커 사이 상호작용을 관리하기 위한 것으로 클라이언트와 브로커는 세션 정보 중 서비스 품질을 나타내는 QoS를 통해 "적어도 한 번" 및 "정확히 한 번" 발행과 "정확히 한 번" 구독을 보장합니다. 또한 구독자가 작성한 구독도 세션 정보에 포함됩니다.

다음은 세션에 저장되는 내용입니다.

- 구독이 없는 세션의 존재 여부
- 모든 구독
- 클라이언트가 확인하지 않은 QoS = 1 또는 QoS = 2 메시지
- 클라이언트가 끊어진 동안 놓친 모든 새로운 QoS = 1 또는 QoS = 2 메시지
- 클라이언트에서 아직 확인되지 않은 모든 수신된 QoS = 2 메시지

클라이언트를 연결할 때 이전 세션 정보를 유지하거나 유지하지 않도록 선택할 수 있는데, 영구 세션(CleanSession = False)은 세션 상태를 유지하고 클린 세션(CleanSession = True)은 유지하지 않습니다.

클라이언트가 클라이언트 ID와 브로커 주소, 클린 세션 여부, 사용자 ID, 비밀번호 또는 인증서를 이용해 브로커에 연결을 요청하면 브로커는 세션 정보가 이전 연결에서 저장되어 있는지 확인합니다. 이전 세션이 존재할 때 클린 세션이면 클라언트와 브로커의 이전 세션 상태는 지워지고 영구 세션이면 이전 세션 상태를 다시 사용합니다. 이전 세션이 없으면 새 세션이 시작됩니다.

#### 발행 
클린 세션으로 클라이언트를 연결하면 보류 중인 모든 발행의 송신이 제거됩니다. 또한 클린 세션에서 QoS = 0으로 발행된 메시지는 영향을 주지 않지만 QoS = 1 및 QoS = 2로 발행한 메시지는 게시되지 않고 잃어버릴 수 있습니다.

#### 구독
세션 상태에서 구독은 논리적으로 클라이언트의 토픽을 연결하며 토픽에 가입한 클라이언트는 게시된 메시지를 수신할 수 있습니다. 클린 세션으로 클라이언트를 연결하면 브로커는 클라이언트에 대한 이전 구독을 모두 제거합니다. 또한 연결이 끊어지면 세션 중에 클라이언트가 만든 모든 새 구독도 함께 제거됩니다. 반면에 영구 세션에서는 클라이언트가 만드는 구독이 연결되기 전에 클라이언트에 있었던 모든 구독에 추가됩니다. 클라이언트가 연결을 끊어도 모든 구독은 활성 상태를 유지합니다.

클린 세션은 기본 세션 모드로 세션 범위 내에서만 게시된 메시지를 받을 수 있으므로 구독은 일시적입니다. 따라서 세션이 닫히면 세션 상태도 지워지므로 이후 게시된 메시지는 잃어버린다. 하지만 영구 세션은 구독이 영구적이므로 클라이언트의 연결을 끊었다가 다시 연결하면 QoS = 1 또는 QoS = 2로 게시된 메시지를 받게 됩니다.

![session](res/session.png)

어떤 세션이든 한 번 만들어지면 전체 세션 동안 지속되므로 모드를 바꾸려면 클라이언트의 연결을 끊었다가 다시 연결하는 방법밖에 없습니다. 영구 세션을 끊고 클린 세션으로 다시 연결하면 클라이언트에 대한 모든 이전 구독 및 수신되지 않은 모든 발행이 삭제됩니다.

#### 클라이언트 ID  
클라이언트 ID는 브로커가 세션 안에서 각각의 클라이언트를 구분하는 유일한 식별자로 숫자와 영문자 대소문자 및 '_' 문자를 조합해 만듭니다. CleanSession = True일 때는 브로커가 동적으로 만들지만 CleanSession = False에서는 클라이언트가 반드시 유효한 문자열로 클라이언트 ID를 부여해야 하는데, 물리적으로 다른 장치에서 동일한 클라이언트 ID를 사용하면 보류 중인 게시 및 활성 구독이 자동으로 새 장치로 전송되므로 장애가 발생한 장치의 이전이 쉽습니다.

브로커가 동적으로 만드는 클라이언트 ID는 고유성이 보장되지만 클라이언트에서 명시적으로 만들 때는 브로커에 이미 등록된 클라이언트 ID인지 알 수 없으므로 128bit 고유 문자열을 생성하는 uuid 툴이나 네트워크 인터페이스의 MAC 주소 등을 사용하는 것과 같이 스스로 특별한 규칙을 적용할 필요가 있습니다.

# MicroPython MQTT

Micropython에서 공식적으로 지원해주는 라이브러리는 없습니다. 이에 다른 사용자 라이브러리인 `umqtt` 를 사용하여 mqtt 통신을 실행합니다. TiCLE Lite에서는 기본적으로 설치되어 있습니다.

## MQTT client 예제

이 예제는 MicroPython 환경에서 umqtt.simple2.MQTTClient를 사용하여 하나의 장치가 메시지를 구독(Subscribe) 하고 발행(Publish) 하는 방법을 실습해봅니다. 외부 Broker 접속을 위한 Wifi 연결부터 MQTT 브로커 연결, 토픽 발행 및 구독 프로세스를 순차적으로 진행합니다.

```python
# mqtt_client_ex.py
import network, utime, ubinascii
from machine import unique_id
from umqtt.simple2 import MQTTClient

WIFI_SSID = "YOUR_WIFI_SSID"
WIFI_PSK = "YOUR_WIFI_PASSWORD"
BROKER = "test.mosquitto.org"
CLIENT_ID = b"mpy-" + ubinascii.hexlify(unique_id())
TOPIC_SUB = b"ticle/demo/in"
TOPIC_PUB = b"ticle/demo/out"

def wifi_connect(ssid, psk, timeout=15000):
    sta = network.WLAN(network.STA_IF)
    if not sta.active():
        sta.active(True)
    if not sta.isconnected():
        sta.connect(ssid, psk)
        start = utime.ticks_ms()
        while not sta.isconnected() and utime.ticks_diff(utime.ticks_ms(), start) < timeout:
            utime.sleep_ms(100)
    return sta.isconnected()

def main():
    if not wifi_connect(WIFI_SSID, WIFI_PSK):
        raise OSError("wifi failed")
    last_pub = 0
    def on_msg(topic, msg, ret, dup):
        c.publish(TOPIC_PUB, b"echo:" + msg)
    c = MQTTClient(CLIENT_ID, BROKER, port=1883, keepalive=30)
    c.set_callback(on_msg)
    c.connect(clean_session=True)
    c.subscribe(TOPIC_SUB)
    c.publish(TOPIC_PUB, b"online")
    while True:
        c.check_msg()
        now = utime.ticks_ms()
        if utime.ticks_diff(now, last_pub) >= 5000:
            c.publish(TOPIC_PUB, b"heartbeat")
            last_pub = now
        utime.sleep_ms(50)

main()
```

`WIFI_SSID`, `WIFI_PSK`는 사용자 환경에 맞는 Wifi 정보를 기입하시고, `BROKER` 는 코드에 작성된 온라인 브로커를 사용하시거나, 다른 브로커를 사용하셔도 무관합니다.

### 코드 설명

```python
def wifi_connect(ssid, psk, timeout=15000):
    sta = network.WLAN(network.STA_IF)
    ...
    return sta.isconnected()
```

이 함수는 장치를 Wi-Fi에 연결하는 함수입니다. `network.WLAN`을 통해 STA 모드로 전환하고, 지정된 SSID와 비밀번호로 접속을 완료합니다. 연결 여부를 반환합니다.

```python
CLIENT_ID = b"mpy-" + ubinascii.hexlify(unique_id())
BROKER = "test.mosquitto.org"
```

이 구문은 MQTT 클라이언트의 식별자와 브로커 주소를 설정하는 부분입니다. 장치의 고유 ID를 이용해 각 장치가 중복되지 않게 구분됩니다.

```python
def on_msg(topic, msg, ret, dup):
    c.publish(TOPIC_PUB, b"echo:" + msg)
```

이 함수는 MQTT 메시지를 수신했을 때 실행되는 콜백입니다. 구독한 토픽에서 메시지를 받으면, 같은 브로커로 “echo:” 접두어를 붙여 다시 발행합니다.

```python
c = MQTTClient(CLIENT_ID, BROKER, port=1883)
c.set_callback(on_msg)
c.connect(clean_session=True)
c.subscribe(TOPIC_SUB)
```

이 부분은 MQTT 통신을 설정하는 핵심 구문입니다. 클라이언트를 생성하고 콜백 함수를 등록한 뒤 브로커에 연결합니다. 이후 구독할 토픽을 지정하여 수신 준비를 마칩니다.

```python
while True:
    c.check_msg()
    ...
    c.publish(TOPIC_PUB, b"heartbeat")
```

이 반복문은 MQTT 송수신을 지속적으로 유지하는 루프입니다. `check_msg()`로 구독 메시지를 확인하며, 일정 주기마다 상태 메시지를 발행합니다.

### 실행

터미널에 다음 명령어를 입력하여 실행시켜 봅니다.

```sh
upy mqtt_client_ex.py
```

이 후, MQTTx 및 mosquitto 툴을 사용하여 `TOPIC_SUB` 에 적힌 토픽에 메시지를 발행하거나, `TOPIC_PUB` 에 적힌 토픽을 구독해 모니터링 해봅니다.

![mqtt_result](pds/mqtt_result.png)