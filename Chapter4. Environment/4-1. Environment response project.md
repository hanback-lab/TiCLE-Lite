# Environment respone TiCLE

## 1. 실습 주제

환경 반응형 LED 매트릭스 만들기


## 2. 프로젝트 개요

가변저항, 마이크, 조도센서 값을 이용해 색상·밝기·크기가 변하는 LED 매트릭스를 구현합니다.

* 가변저항 → 색상(H)
* 조도센서 → 밝기(V)
* 마이크 → 중심 원의 반경
  센서 입력에 따라 색상과 형태가 실시간으로 바뀌는 반응형 디스플레이를 구성합니다.


## 3. 개념 설명

* ADC 정규화: 센서 입력(0~65535)을 0~1로 변환하여 계산을 단순화합니다.
* HSV 색상 모델: 색상(H), 채도(S), 밝기(V)을 조합해 RGB로 변환해 LED 색을 만듭니다.
* 원형 패턴: 중심에서 각 픽셀까지의 거리 제곱을 반경 제곱과 비교하여 원 내부만 켭니다.


## 4. 코드 전체

```python
from machine import Pin, ADC
from ws2812 import WS2812Matrix
import utime, math

W=16; H=16
vr=ADC(Pin(28)); mic=ADC(Pin(26)); cds=ADC(Pin(27))
matrix=WS2812Matrix([(3,1)]); matrix.clear()
cx=(W-1)/2; cy=(H-1)/2

def n(v): return v/65535.0
def c8(x): 
    if x<0: return 0
    if x>255: return 255
    return int(x)
def hsv(h,s,v):
    i=int(h*6); frac=h*6-i; p=v*(1-s); q=v*(1-frac*s); t=v*(1-(1-frac)*s); i%=6
    r,g,b=(v,t,p) if i==0 else (q,v,p) if i==1 else (p,v,t) if i==2 else (p,q,v) if i==3 else (t,p,v) if i==4 else (v,p,q)
    return c8(r*255),c8(g*255),c8(b*255)

while True:
    hue_v=n(vr.read_u16())
    mic_norm=n(mic.read_u16())
    bright_v=1.0-n(cds.read_u16())

    rr,rg,rb=hsv(hue_v,0.95,bright_v)
    radius=1+int(mic_norm*4+1e-3)
    if radius>5: radius=5
    radius2=radius*radius
    green_core=c8(255*bright_v)

    for y in range(H):
        for x in range(W):
            if x==0 or x==W-1 or y==0 or y==H-1:
                matrix[x,y].value=(rr,rg,rb)
            else:
                dx=x-cx; dy=y-cy
                matrix[x,y].value=(0,green_core,0) if dx*dx+dy*dy<=radius2 else (0,0,0)

    matrix.update()
    utime.sleep_ms(30)

```

---

## 5. 코드 요약

### (0) 유틸리티 함수

* `n(v)`: 16비트 ADC 값을 0~1로 정규화합니다. 이후 모든 계산을 같은 스케일에서 다룰 수 있게 합니다.
* `c8(x)`: 색 채널 값을 0~255로 제한합니다. LED에 보낼 안전한 정수 범위를 보장합니다.
* `hsv(h, s, v)`: HSV를 RGB로 변환합니다. `h`는 0~1 범위 색상환, `s`는 채도, `v`는 밝기이며, 내부에서 분기·보간으로 최종 `(r,g,b)`를 산출합니다.

### (1) 센서값 정규화

세 센서를 0~1로 맞추며, 조도는 어두울수록 크게 보이도록 1에서 뺍니다.

```python
hue_v=n(vr.read_u16())
mic_norm=n(mic.read_u16())
bright_v=1.0-n(cds.read_u16())
```

### (2) 테두리 색상 계산

HSV(H=hue_v, S=0.95, V=bright_v)를 RGB로 변환하여 테두리 색을 결정합니다.

```python
rr,rg,rb=hsv(hue_v,0.95,bright_v)
```

### (3) 원 반경 계산

마이크 값으로 반경을 1~5 범위의 정수로 양자화하고, 거리 비교용 제곱을 준비합니다.

```python
radius=1+int(mic_norm*4+1e-3)
if radius>5: radius=5
radius2=radius*radius
```

### (4) 픽셀 표시

경계는 테두리 색, 내부는 중심 거리 제곱 ≤ 반경 제곱일 때만 녹색으로 켭니다.

```python
if x==0 or x==W-1 or y==0 or y==H-1:
    matrix[x,y]=(rr,rg,rb)
else:
    dx=x-cx; dy=y-cy
    matrix[x,y]=(0,green_core,0) if dx*dx+dy*dy<=radius2 else (0,0,0)
```

### (5) LED 갱신

한 프레임을 모두 계산한 뒤 LED를 업데이트하고 잠시 대기합니다.

```python
matrix.update()
utime.sleep_ms(30)
```

---

## 6. 결과 확인

* 가변저항을 돌리시면 테두리 색상이 변합니다.
* 주변이 어두우면 LED가 더 밝아집니다.
* 소리가 커지면 중심의 녹색 원이 커집니다.

---

## 7. 연습문제

1. 중심 원의 색을 HSV 기반으로 바꾸어 보세요.
2. 테두리를 제거하고, 조도에 따라 전체 밝기만 변하도록 구성해 보세요.
