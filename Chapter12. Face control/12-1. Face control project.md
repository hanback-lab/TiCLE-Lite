# PBL ì‹¤ìŠµí˜• êµì¬ ë¬¸ì„œ (PCâ€“Pico ì—°ë™í˜•)

## 1. ì‹¤ìŠµ ì£¼ì œ

**ì›¹ìº  í‘œì • ì¸ì‹ ê²°ê³¼ë¥¼ WS2812 ë§¤íŠ¸ë¦­ìŠ¤ ì´ëª¨ì§€ë¡œ ì‹¤ì‹œê°„ í‘œí˜„í•˜ê¸°**

## 2. í”„ë¡œì íŠ¸ ê°œìš”

PCê°€ ì›¹ìº ì—ì„œ ì–¼êµ´ì„ ì¶”ì •Â·ë¶„ë¥˜í•´ **ê°ì • ë ˆì´ë¸”(happy/sad/angry)** ì„ MQTTë¡œ ë°œí–‰í•©ë‹ˆë‹¤.
PicoëŠ” í•´ë‹¹ ë ˆì´ë¸”ì„ ë°›ì•„ 16Ã—16 WS2812 ë§¤íŠ¸ë¦­ìŠ¤ì— **ê°„ë‹¨í•œ ì´ëª¨ì§€**ë¥¼ ê·¸ë ¤ í‘œì‹œí•©ë‹ˆë‹¤.

## 3. ì„ í–‰ ì‘ì—… (ì‘ì„± ì¹¸)

* (PC) íŒ¨í‚¤ì§€ ì„¤ì¹˜, ëª¨ë¸ íŒŒì¼ ë°°ì¹˜, GPU/CPU ì„¤ì •
* (Pico) ë„¤íŠ¸ì›Œí¬ ì—°ê²°, í† í”½/ì™€ì´íŒŒì´ ì„¤ì •
* (ê³µí†µ) ë¸Œë¡œì»¤ ì—°ê²° í…ŒìŠ¤íŠ¸
  ğŸ“¸ (ì¤€ë¹„ë¬¼/ë°°ì„  ì‚¬ì§„ ì²¨ë¶€ ì¹¸)

## 4. ê°œë… ì„¤ëª… â€” EmoAffectnet ê°„ë‹¨ ì†Œê°œ

ì‚¬ì „ í•™ìŠµëœ ê°ì • ì¸ì‹ ëª¨ë¸ì´ ì–¼êµ´ ì´ë¯¸ì§€ë¥¼ ì…ë ¥ë°›ì•„ **7ê°œ í´ë˜ìŠ¤(Neutral, Happiness, Sadness, Surprise, Fear, Disgust, Anger)** í™•ë¥ ì„ ì¶œë ¥í•©ë‹ˆë‹¤.
ë³¸ ì˜ˆì œëŠ” MediaPipeë¡œ ì–¼êµ´ ROIë¥¼ ì¶”ì¶œí•œ ë’¤ TorchScript ëª¨ë¸ë¡œ ì¶”ë¡ í•˜ê³ , ê²°ê³¼ë¥¼ **happy/sad/angry** ì…‹ìœ¼ë¡œ ë§¤í•‘í•´ ì‚¬ìš©í•©ë‹ˆë‹¤.
PicoëŠ” ìˆ˜ì‹  ë ˆì´ë¸”ì— ë§ì¶° **ëˆˆ/ì…/ì¥ì‹ ë§** ë“± í”½ì…€ íŒ¨í„´ì„ ì¡°í•©í•´ ì´ëª¨ì§€ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.

---

## 5. PC ì½”ë“œ

```python
import cv2, math, numpy as np, time
import mediapipe as mp
import torch
from PIL import Image
from torchvision import transforms
import paho.mqtt.client as mqtt

BROKER="test.mosquitto.org"; PORT=1883; TOPIC="ticle/emo"

def pth_processing(fp):
    class PreprocessInput(torch.nn.Module):
        def __init__(self): super().__init__()
        def forward(self, x):
            x = x.to(torch.float32)
            x = torch.flip(x, dims=(0,))
            x[0, :, :] -= 91.4953; x[1, :, :] -= 103.8827; x[2, :, :] -= 131.0912
            return x
    ttransform = transforms.Compose([transforms.PILToTensor(), PreprocessInput()])
    img = fp.resize((224, 224), Image.Resampling.NEAREST)
    img = ttransform(img)
    return torch.unsqueeze(img, 0).to('cuda')

def norm_coordinates(nx, ny, w, h):
    x = min(math.floor(nx * w), w - 1); y = min(math.floor(ny * h), h - 1); return x, y

def get_box(fl, w, h):
    pts = [(norm_coordinates(l.x, l.y, w, h)) for l in fl.landmark]
    xs = np.asarray([p[0] for p in pts]); ys = np.asarray([p[1] for p in pts])
    x0, y0, x1, y1 = xs.min(), ys.min(), xs.max(), ys.max()
    return max(0, x0), max(0, y0), min(w - 1, x1), min(h - 1, y1)

def display_EMO_PRED(img, box, label, lw=2):
    p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))
    cv2.rectangle(img, p1, p2, (255, 0, 255), lw, cv2.LINE_AA)
    cv2.putText(img, label, (p1[0], max(10, p1[1]-6)), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,0,255), 2, cv2.LINE_AA)
    return img

def display_FPS(img, text):
    cv2.putText(img, text, (10, 22), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,0,0), 2, cv2.LINE_AA)
    cv2.putText(img, text, (10, 22), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 1, cv2.LINE_AA)
    return img

mp_face_mesh = mp.solutions.face_mesh
name = '0_66_49_wo_gl'
pth_model = torch.jit.load(f'models_EmoAffectnet/torchscript_model_{name}.pth').to('cuda').eval()
DICT_EMO = {0:'Neutral',1:'Happiness',2:'Sadness',3:'Surprise',4:'Fear',5:'Disgust',6:'Anger'}

client = mqtt.Client(client_id="pc_emo_pub"); client.connect(BROKER, PORT, 60); client.loop_start()

cap = cv2.VideoCapture(0)
w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)); h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
last_sent = None; last_t = 0

with mp_face_mesh.FaceMesh(max_num_faces=1, refine_landmarks=False, min_detection_confidence=0.5, min_tracking_confidence=0.5) as face_mesh:
    while cap.isOpened():
        t1 = time.time()
        ok, frame = cap.read()
        if not ok: break

        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        res = face_mesh.process(rgb)

        if res.multi_face_landmarks:
            fl = res.multi_face_landmarks[0]
            x0,y0,x1,y1 = get_box(fl, w, h)
            face_roi = rgb[y0:y1, x0:x1]
            if face_roi.size > 0:
                inp = pth_processing(Image.fromarray(face_roi))
                prob = torch.nn.functional.softmax(pth_model(inp), dim=1).cpu().detach().numpy()[0]
                cls = int(np.argmax(prob)); label = DICT_EMO.get(cls, "Unknown")
                frame = display_EMO_PRED(frame, (x0,y0,x1,y1), label, 3)

                mapped = None
                if label=="Happiness": mapped="happy"
                elif label=="Sadness": mapped="sad"
                elif label=="Anger": mapped="angry"

                now = time.time()
                if mapped and (mapped!=last_sent or now-last_t>1.0):
                    client.publish(TOPIC, mapped.encode(), qos=0, retain=False)
                    last_sent = mapped; last_t = now

        fps = 1.0/max(1e-6, time.time()-t1)
        frame = display_FPS(frame, f'FPS: {fps:.1f}')
        cv2.imshow('Emo â†’ MQTT', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'): break

cap.release(); cv2.destroyAllWindows()
client.loop_stop(); client.disconnect()
```

## 6. Pico ì½”ë“œ

```python
from ticle import WifiManager
from umqtt.simple2 import MQTTClient
from ws2812 import WS2812Matrix
import utime, math

W=16; H=16
m=WS2812Matrix([(3,1)])
m.clear()

Y=(255,200,0)
WHT=(255,255,255)
B=(0,160,255)
R=(255,70,70)
K=(0,0,0)

TOPIC=b"ticle/emo"
mode="happy"

cx=(W-1)/2; cy=(H-1)/2

def px(x,y,c):
    if 0<=x<W and 0<=y<H: m[x,y]=c

def clear():
    for y in range(H):
        for x in range(W): m[x,y]=K

def ring():
    for deg in range(0,360,2):
        r=7
        rad=math.radians(deg)
        x=int(cx+math.cos(rad)*r); y=int(cy+math.sin(rad)*r)
        px(x,y,Y)

def line(x0,y0,x1,y1,c):
    dx=abs(x1-x0); sx=1 if x0<x1 else -1
    dy=-abs(y1-y0); sy=1 if y0<y1 else -1
    err=dx+dy
    while True:
        px(x0,y0,c)
        if x0==x1 and y0==y1: break
        e2=2*err
        if e2>=dy: err+=dy; x0+=sx
        if e2<=dx: err+=dx; y0+=sy

def arc(points,c):
    for i in range(len(points)-1):
        x0,y0=points[i]; x1,y1=points[i+1]
        line(x0,y0,x1,y1,c)

def smile_curve(c):
    pts=[]
    for x in range(4,12):
        t=(x-cx)/4.0
        y=int(cy+2.5 - 2.0*(t*t)) + 2
        pts.append((x,y))
    arc(pts,c)

def frown_curve(c):
    pts=[]
    for x in range(4,12):
        t=(x-cx)/4.0
        y=int(cy-2.5 + 2.0*(t*t)) + 3
        pts.append((x,y))
    arc(pts,c)

def flat_curve(y,c):
    line(5,y,10,y,c)

def eyes_dots(c):
    px(5,6,c); px(10,6,c)

def eyes_slits(c):
    line(4,7,6,7,c); line(9,7,11,7,c)

def brows_angry(c):
    line(4,5,7,3,c); line(11,5,8,3,c)

def tears(c):
    line(5,7,5,12,c); line(10,7,10,12,c)

def emo_happy():
    clear(); ring(); eyes_dots(WHT); smile_curve(WHT)

def emo_sad():
    clear(); ring(); eyes_dots(WHT); tears(B); frown_curve(WHT)

def emo_angry():
    clear(); ring(); brows_angry(R); eyes_slits(WHT); flat_curve(11,R)

def draw():
    if mode=="happy": emo_happy()
    elif mode=="sad": emo_sad()
    else: emo_angry()
    m.update()

wifi=WifiManager()
wifi.connect("HBE_RSP","hanback91!")

def on_msg(t,msg,ret,dup):
    global mode
    s=msg.decode().strip().lower()
    if s in ("happy","sad","angry"):
        mode=s
        draw()

c=MQTTClient("pico_emo","test.mosquitto.org",port=1883)
c.set_callback(on_msg)
c.connect()
c.subscribe(TOPIC)

draw()

while True:
    c.check_msg()
    utime.sleep_ms(20)

```

---

## 7. ì½”ë“œ ìš”ì•½ (í•µì‹¬ ë¡œì§ë§Œ ì½”ë“œë¸”ë¡ìœ¼ë¡œ ë¶„ë¦¬)

### ğŸ’» PC í•µì‹¬ ë¡œì§

#### 7-1) ì–¼êµ´ ROI ì¶”ì¶œ

```python
with mp.solutions.face_mesh.FaceMesh(max_num_faces=1, ...) as face_mesh:
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    res = face_mesh.process(rgb)
    if res.multi_face_landmarks:
        fl = res.multi_face_landmarks[0]
        x0,y0,x1,y1 = get_box(fl, w, h)
        face_roi = rgb[y0:y1, x0:x1]
```

#### 7-2) ì „ì²˜ë¦¬ â†’ ëª¨ë¸ ì¶”ë¡ 

```python
inp = pth_processing(Image.fromarray(face_roi))  # 224x224 + ì±„ë„ ì „ì²˜ë¦¬
logits = pth_model(inp)
prob = torch.nn.functional.softmax(logits, dim=1).cpu().numpy()[0]
cls = int(np.argmax(prob))
label = DICT_EMO.get(cls, "Unknown")
```

#### 7-3) ë ˆì´ë¸” ë§¤í•‘ â†’ ë°œí–‰(ë³€í™” ì‹œ/ì£¼ê¸°ì )

```python
mapped = "happy" if label=="Happiness" else "sad" if label=="Sadness" \
         else "angry" if label=="Anger" else None
if mapped and (mapped != last_sent or time.time()-last_t > 1.0):
    client.publish(TOPIC, mapped.encode(), qos=0, retain=False)
    last_sent, last_t = mapped, time.time()
```

#### 7-4) ì‹œê° í™•ì¸(ë°•ìŠ¤/ë¼ë²¨/FPS)

```python
frame = display_EMO_PRED(frame, (x0,y0,x1,y1), label, 3)
frame = display_FPS(frame, f'FPS: {fps:.1f}')
```

---

### ğŸ§  Pico í•µì‹¬ ë¡œì§

#### 7-5) ë ˆì´ë¸” ìˆ˜ì‹  â†’ ì¦‰ì‹œ ë Œë”

```python
mode = "happy"

def on_msg(t, msg, ret, dup):
    global mode
    s = msg.decode().strip().lower()
    if s in ("happy","sad","angry"):
        mode = s
        draw()          # í˜„ì¬ ëª¨ë“œì˜ ì´ëª¨ì§€ ì¦‰ì‹œ ì¬ê·¸ë¦¬ê¸°
```

#### 7-6) ì´ëª¨ì§€ í”„ë¦¬ì…‹(ë¬¶ìŒ ì„¤ëª…)

```python
def emo_happy():  clear(); ring(); eyes_dots(WHT);  smile_curve(WHT)
def emo_sad():    clear(); ring(); eyes_dots(WHT);  tears(B); frown_curve(WHT)
def emo_angry():  clear(); ring(); brows_angry(R);  eyes_slits(WHT); flat_curve(11,R)

def draw():
    (emo_happy if mode=="happy" else emo_sad if mode=="sad" else emo_angry)()
    m.update()
```

* `ring/eyes_*/brows_*/smile_curve/frown_curve/flat_curve` ë“± **ì‘ì€ ë„í˜• í•¨ìˆ˜**ë¥¼ ì¡°í•©í•´ í‘œì •ì„ êµ¬ì„±í•©ë‹ˆë‹¤.

#### 7-7) ê¸°ë³¸ ë„í˜•(ì˜ˆì‹œ 2ê°œ)

```python
def line(x0,y0,x1,y1,c):
    dx=abs(x1-x0); sx=1 if x0<x1 else -1
    dy=-abs(y1-y0); sy=1 if y0<y1 else -1
    err=dx+dy
    while True:
        px(x0,y0,c)
        if x0==x1 and y0==y1: break
        e2=2*err
        if e2>=dy: err+=dy; x0+=sx
        if e2<=dx: err+=dx; y0+=sy

def smile_curve(c):
    pts=[]
    for x in range(4,12):
        t=(x-cx)/4.0
        y=int(cy+2.5 - 2.0*(t*t)) + 2
        pts.append((x,y))
    arc(pts,c)
```

---

## 8. ê²°ê³¼ í™•ì¸

* PC ì°½ì— ì–¼êµ´ ë°•ìŠ¤/ê°ì • ë ˆì´ë¸”Â·FPSê°€ í‘œì‹œë©ë‹ˆë‹¤.
* ë§¤íŠ¸ë¦­ìŠ¤ì—ëŠ” **ì›ƒìŒ/ìŠ¬í””/í™”ë‚¨** ì´ëª¨ì§€ê°€ ì¦‰ì‹œ ì „í™˜ë˜ì–´ ì¶œë ¥ë©ë‹ˆë‹¤.

ğŸ“¸ (PC ì¶”ë¡  í™”ë©´ ìº¡ì²˜ ì²¨ë¶€ ì¹¸)
ğŸ“¸ (WS2812 ë§¤íŠ¸ë¦­ìŠ¤ ì´ëª¨ì§€ ì‚¬ì§„ ì²¨ë¶€ ì¹¸)

## 9. ì—°ìŠµë¬¸ì œ

1. `surprise`, `neutral` ì´ëª¨ì§€ë¥¼ ì¶”ê°€í•´ 5ì¢…ìœ¼ë¡œ í™•ì¥í•˜ì„¸ìš”.
2. ê°™ì€ ë ˆì´ë¸” ì—°ì† ì‹œ ë°œí–‰ ì£¼ê¸°ë¥¼ 2ì´ˆë¡œ ì œí•œí•´ ë„¤íŠ¸ì›Œí¬ ë¶€í•˜ë¥¼ ë¹„êµí•˜ì„¸ìš”.
3. ê°ì •ë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ë¥¼ ë°”ê¿” ê°€ë…ì„±ì„ ë†’ì—¬ ë³´ì„¸ìš”.
