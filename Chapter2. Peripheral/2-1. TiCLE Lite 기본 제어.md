# 기본 제어

이 장에서는 Micropython을 통해 TiCLE LiTE 장비에 기초적인 제어를 하고자 합니다.

Micropython이란 Python 3 언어를 최소화 및 효율성을 증진시킨 언어이며, Python의 기본 문법과 표준 라이브러리의 기본 기능을 포함하고 마이크로컨트롤러와 같은 제한된 환경에서 실행되도록 기획된 언어입니다. 또한, `machine` 라이브러리를 기본으로 제공하여 마이크로컨트롤러의 기능 사용 및 확장 등의 작업들에 용이하게 사용할 수 있도록 제공해줍니다.

본 교재는 TiCLE Lite에 장착된 센서 및 액추에이터를 제어하는 수준으로써의 간략한 버전으로 설명을 제공합니다. 보다 더 자세한 기능에 대해 알아가고 싶으시다면 아래 링크를 참고해주시길 바랍니다.

- https://docs.micropython.org/en/latest/library/index.html#python-standard-libraries-and-micro-libraries

## GPIO

GPIO는 `General Purpose Input Output`의 약자로 말 그대로 범용으로 사용되는 입출력 포트를 의미합니다. 여러가지 다양한 용도로 사용될 수 있다는 것을 의미하기도 합니다. TiCLE Lite에는 마이크로컨트롤러 외에 여러가지 다양한 일을 수행하는 주변장치 및 소자들이 존재합니다. 이 주변 소자들은 MCU의 미리 정해진 인터페이스에 연결되어 동작 하는 것 들도 있지만, 그렇지 않은 경우가 더 많습니다. 이러한 다양한 주변 소자들을 동작 시키기 위해서는 그 주변소자들이 원하는 방식으로 인터페이스를 하여 원하는 신호를 보내주어야 합니다. 예를 들어 LED를 켜거나, 버저를 울리기 위해서는 그 소자에 0 혹은 1의 신호를 보내주어야 하고, TEXT-LCD에 글자를 출력하기 위해서는 좀 더 복잡한 병렬 신호들을 보내 주어야 합니다. 또한, 스위치나 마이크 등의 입력을 받기 위해서는 그 소자들로부터 나오는 신호를 받아들일 수 있는 통로를 가져야 합니다다 이와 같이 TiCLE Lite에서 일어나는 여러 가지 다양한 일들을 처리하기 위해 프로그래머가 마음대로 변형하면서 제어할 수 있도록 제공해 주는 I/O(입출력) 포트를 GPIO라고 합니다.

TiCLE Lite에 장착된 RP2350 마이크로컨트롤러 또한 많은 수의 GPIO 포트를 보유하고 있습니다. 사실 특수한 용도로 사용하는 몇몇 핀을 제외하고는 거의 모든 핀들이 GPIO로 사용할 수 있다고 보아도 무방합니다. 그만큼 마이크로컨트롤러에서 GPIO의 중요성은 매우 크다고 할 수 있으며, 어떤 고성능 마이크로컨트롤러나 SoC에서도 이러한 경향은 마찬가지입니다.

Micropython에서 GPIO 제어는 `machine` 라이브러리의 `Pin` 클래스를 사용하여 제어합니다.

### LED

아래 사진과 같이 Raspberry Pi Pico 2 W 위에 위치한 LED를 제어합니다.

![leds](pds/led.png)

VSCode 상에서 아래와 같이 코드를 작성한 후 'led.py' 라는 이름으로 저장합니다.

```py
# led.py
from machine import Pin
from utime

led_pin = Pin('LED', Pin.OUT)

led_pin.on()
utime.sleep_ms(1000)
led_pin.off()
utime.sleep_ms(1000)

led_pin.value = 1
utime.sleep_ms(1000)
led_pin.value = 0
utime.sleep_ms(1000)
```

4번 개행 줄의 `Pin` 클래스를 생성하는 과정을 주목해 봅니다. 상술하였듯 `machine` 라이브러리에는 마이크로컨트롤러 제어에 필요한 다양한 기능들이 담겨져 있으며, 그 기능들 중 GPIO 제어를 담당하고 있는 `Pin` 클래스를 들고와 인스턴스를 생성합니다. 인스턴스를 생성할 때 두 가지 기본 인자값을 받습니다. 젓 번째는 핀 번호이고, 두 번째는 입출력 방향입니다. 핀 번호는 제어하고자 하는 센서 및 액추에이터과 같은 주변장치가 연결된 핀 번호를 입력해주면 됩니다. 일반적으로 자연수 값이 입력되며, 지금과 같이 Raspberry Pi Pico 2 W 보드 위에 있는 LED를 제어할 때는 특수한 경우로 'LED' 라고 기입합니다. 입출력 방향은 각종 주변장치에 신호를 보낼 지, 아님 신호를 받을 지를 결정해주면 됩니다. 지금은 LED 출력을 제어해 줄 것이기 때문에 `Pin.OUT`, 즉 출력 방향으로 설정해줍니다.

그 이후의 코드는 총 2번 씩 LED가 번갈아 점멸하는 기능을 지시하는 코드입니다. 점멸 주기는 1초이며, 시간과 관련된 기능들이 포함된 라이브러리 `utime` 에서 명시된 시간만큼 동작을 정지시키는 `sleep_ms()` 함수를 통해 주기를 설정해줍니다. 여기서 `sleep_ms` 함수의 인자값은 miliseconds 단위이며, 1 밀리초는 $1*10^{-3}$ 초와 같습니다.

led와 연결된 핀을 제어하는 방법은 총 두 가지가 있습니다. 하나는 `on`/`off` 함수를 사용하는 것이고, 다른 하나는 Pin 클래스의 멤버 변수 `value`의 값을 조정하는 것입니다. `value` 변수는 프로퍼티로 설정되어 있어 실시간으로 값을 읽거나 받을 수 있고, `on`/`off` 함수 또한 본질적으로 `value` 변수의 값을 수정하고 있습니다. 결론적으로 두 가지 방법 다 동일한 결과를 출력하며, 코딩 스타일에 따라 선택할 수 있는 폭이 넓어진 것과 같습니다.

터미널에 다음 명령어를 입력하여 프로그램을 실행시키면, Raspberry Pi Pico 2 W에 부착된 LED가 점멸하는 것을 확인할 수 있습니다.

```sh
upy led.py
```

### Switch

아래 사진과 같이 위치한 Switch를 제어해 보겠습니다.

![switch_pic]()

Raspberry Pi Pico 2 W에 부착되었던 LED와는 달리, Switch는 별도의 결선이 필요합니다. 점퍼 케이블 등을 이용하여 아래의 표, 사진을 참고하여 Pin을 결선시켜 줍니다.

| 명칭 | 핀 번호 |
| --- | ------ |
| UP | 18 |
| LEFT | 19 |
| DOWN | 20 |
| RIGHT | 21 |

![pin_pic]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'switch.py' 라는 이름으로 저장합니다.

```py
# switch.py
from machine import Pin
import utime

up_sw_pin = Pin(18, Pin.IN)
left_sw_pin = Pin(19, Pin.IN)
down_sw_pin = Pin(20, Pin.IN)
right_sw_pin = Pin(21, Pin.IN)

for i in range(10):
    print(f"up: {up_sw_pin.value}, left: {left_sw_pin.value}, down: {down_sw_pin.value}, right: {right_sw_pin.value}")
    utime.sleep_ms(500)
```

버튼의 입력을 받는 것 또한 `Pin` 클래스를 사용합니다. 상술하였듯 `value` 멤버 변수는 프로퍼티로 구현되었기 때문에, 실시간으로 핀의 상태값을 확인받을 수 있습니다.

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 버튼을 눌림 상태에 따라 프로그램 출력값이 달라지는 것을 확인할 수 있습니다.

```sh
upy switch.py
```

### IR Remote

IR Remote란 적외선을 통해 지정된 명령 신호를 단방향으로 통신하는 것을 말합니다. IR 신호를 보내는 장치는 TiCLE Lite와 동봉된 IR 리모컨이며, 신호를 받는 장치는 아래 사진과 같이 위치한 센서입니다.

![ir_sensor]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'ir.py' 라는 이름으로 저장합니다. 리모컨의 버튼 입력에 따라 ir 값이 바뀌는 것을 확인할 수 있습니다.

```py
# ir.py
from machine import Pin
import time

class IRNECPoll:
    def __init__(self, pin, active_low=True):
        self.p = pin if isinstance(pin, Pin) else Pin(pin, Pin.IN)
        self.al = active_low
        self.last = None
        self.last_ts = 0

    def _wait_edge(self, to_ms):
        t0 = time.ticks_ms()
        lv = self.p.value()
        while time.ticks_diff(time.ticks_ms(), t0) < to_ms:
            v = self.p.value()
            if v != lv:
                return lv, time.ticks_us()
        return None, None

    def _capture(self, start_to_ms=200, gap_us=14000, min_us=100, max_ms=120):
        lv, t0 = self._wait_edge(start_to_ms)
        if t0 is None: return None
        seg, start_ms, last = [], time.ticks_ms(), t0
        while time.ticks_diff(time.ticks_ms(), start_ms) < max_ms:
            v = self.p.value()
            if v != lv:
                t = time.ticks_us()
                d = time.ticks_diff(t, last)
                if d >= min_us: seg.append((lv, d))
                lv, last = v, t
            else:
                if time.ticks_diff(time.ticks_us(), last) > gap_us and len(seg) > 8:
                    break
        if not seg: return None
        out = []
        l, d = seg[0]
        for nl, nd in seg[1:]:
            if nl == l: d += nd
            else: out.append((l, d)); l, d = nl, nd
        out.append((l, d))
        m = 0 if self.al else 1
        return [(0 if L==m else 1, D) for L, D in out]

    def _inr(self, x, tgt, tol):
        return (tgt*(1-tol)) <= x <= (tgt*(1+tol))

    def _median(self, a):
        if not a: return 0
        a = sorted(a); return a[len(a)//2]

    def _nec_decode(self, fr, tol=0.25):
        i = 0
        while i < len(fr) and fr[i][0] == 1: i += 1
        fr = fr[i:]
        if len(fr) < 66: 
            if len(fr) >= 4:
                h_ok = (fr[0][0]==0 and self._inr(fr[0][1],9000,0.35)) and (fr[1][0]==1 and self._inr(fr[1][1],2250,0.35))
                if h_ok: return ("REPEAT",)
            return None
        if not (fr[0][0]==0 and self._inr(fr[0][1],9000,0.35)): return None
        if not (fr[1][0]==1 and self._inr(fr[1][1],4500,0.35)): return None
        spaces = [d for l,d in fr if l==1]
        if not spaces: return None
        med = self._median(spaces)
        lo = [v for v in spaces if v<=med]; hi = [v for v in spaces if v>med]
        if not lo or not hi: return None
        mu0 = sum(lo)//len(lo); mu1 = sum(hi)//len(hi)
        if mu0>mu1: mu0,mu1=mu1,mu0
        th = (mu0+mu1)//2
        bits = []
        idx = 2
        for _ in range(32):
            if idx+1 >= len(fr): return None
            if not (fr[idx][0]==0 and self._inr(fr[idx][1],560,0.5)): return None
            if fr[idx+1][0]!=1: return None
            b = 1 if fr[idx+1][1]>th else 0
            bits.append(b)
            idx += 2
        def b2(x):
            v=0
            for i in range(8): v|=(bits[x+i]&1)<<i
            return v
        b0,b1,b2v,b3=b2(0),b2(8),b2(16),b2(24)
        if b1 == (0xFF ^ b0) and b3 == (0xFF ^ b2v):
            return ("NEC", b0, b2v)
        if b3 == (0xFF ^ b2v):
            addr = (b1<<8)|b0
            return ("NECX", addr, b2v)
        return None

    def read(self, start_to_ms=200, gap_us=14000, min_us=100, max_ms=120, repeat_window_ms=400):
        fr = self._capture(start_to_ms, gap_us, min_us, max_ms)
        if not fr: return None
        r = self._nec_decode(fr)
        if not r: return None
        if r[0]=="REPEAT":
            if self.last and time.ticks_diff(time.ticks_ms(), self.last_ts)<=repeat_window_ms:
                return self.last
            return None
        if r[0] in ("NEC","NECX"):
            self.last = (r[1], r[2])
            self.last_ts = time.ticks_ms()
            return self.last
        return None

ir = IRNECPoll(pin=17)

while True:
    pkt = ir.read()
    if pkt:
        a,c = pkt
        if a<=0xFF: s = f"A=0x{a:02X} C=0x{c:02X}"
        else: s = f"A=0x{a:04X} C=0x{c:02X}"
        print(s)
    time.sleep_ms(5)
```

이 코드는 적외선 수신기를 통해 리모컨에서 들어오는 신호를 감지한 뒤, NEC 프로토콜을 사용해 데이터를 해석합니다. 신호의 길이와 간격을 비교하여 버튼에 해당하는 값을 찾아내며, 같은 버튼을 눌렀을 때는 항상 일정한 결과가 나오도록 설계되어 있습니다.

각 함수는 비교적 단순한 역할을 합니다. 신호가 처음 들어올 때까지 기다리고, 일정 시간 동안 감지된 신호를 하나의 묶음으로 저장합니다. 그 안의 패턴을 살펴 NEC 형식에 맞는 데이터인지 확인하고, 주소와 명령 값을 구분해 반환합니다. 또한 버튼을 길게 누를 때 반복되는 신호는 이전에 해석된 값으로 처리합니다.

이 과정을 거치지 않으면 신호가 불규칙해져 잡음이 섞이고, 결과가 불안정해집니다. 따라서 이러한 절차를 통해서만 안정적이고 의미 있는 데이터를 얻을 수 있습니다.

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 리모컨 버튼의 눌림 상태에 따라 프로그램 출력값이 달라지는 것을 확인할 수 있습니다.

```sh
upy ir.py
```

터미널 출력 결과

```
A=0x00 C=0x52
A=0x00 C=0x42
A=0x00 C=0x42
A=0x00 C=0x42
A=0x00 C=0x42
```

이렇게 해서 `machine` 라이브러리를 사용해 코드를 작성하였습니다. 하지만, 코드의 난이도가 너무 어려우며 길이도 매우 방대합니다. 본 교재에서는 캡스톤 디자인이 주 목적이기에 이를 간략히 추상화한 라이브러리 파일을 제공해드립니다.

<details>
<summary>ir_remote.py</summary>

```python
# ir_remote.py

from machine import Pin
import time
from collections import deque

def us():
    return time.ticks_us()

def diff(a, b):
    return time.ticks_diff(a, b)

def in_range(v, target, tol=0.25):
    lo = target * (1.0 - tol)
    hi = target * (1.0 + tol)
    return lo <= v <= hi

NEC_HDR_MARK   = 9000
NEC_HDR_SPACE  = 4500
NEC_RPT_SPACE  = 2250
NEC_BIT_MARK   = 560
NEC_ZERO_SPACE = 560
NEC_ONE_SPACE  = 1690
NEC_FRAME_BITS = 32
NEC_TRAIL_MARK = 560
NEC_GAP        = 30000

SIRC_HDR_MARK  = 2400
SIRC_HDR_SPACE = 600
SIRC_ONE_MARK  = 1200
SIRC_ZERO_MARK = 600
SIRC_BIT_SPACE = 600
SIRC_GAP       = 15000


class IRFrame:
    def __init__(self, protocol, address=None, command=None, bits=None, value=None, repeat=False, raw=None):
        self.protocol = protocol
        self.address = address
        self.command = command
        self.bits = bits
        self.value = value
        self.repeat = repeat
        self.raw = raw or []

    def __repr__(self):
        return "<IRFrame proto=%s addr=%s cmd=%s bits=%s repeat=%s>" % (
            self.protocol, self.address, self.command, self.bits, self.repeat
        )


class IRReceiver:
    def __init__(self, pin, active_low=True, buf_len=256, gap_us=None, cb=None):
        self.pin = pin if isinstance(pin, Pin) else Pin(pin, Pin.IN, Pin.PULL_UP if active_low else Pin.PULL_DOWN)
        self.active_low = active_low
        self.buf = deque((),buf_len)
        self.last_edge = us()
        self.last_level = self.pin.value()
        self.gap_us = gap_us or NEC_GAP
        self.cb = cb
        self._last_nec = None
        self.pin.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=self._irq)

    def _irq(self, pin):
        t = us()
        lv = pin.value()
        dt = diff(t, self.last_edge)
        try:
            self.buf.append((dt, self.last_level))
        except IndexError:
            pass
        self.last_edge = t
        self.last_level = lv

    def _drain_frame(self):
        if not self.buf:
            return None
        local = []
        n = len(self.buf)
        gap_idx = -1
        for i in range(n):
            dt, lvl = self.buf[i]
            if dt >= self.gap_us:
                gap_idx = i
                break
        if gap_idx < 0:
            return None
        take = gap_idx
        for _ in range(take):
            local.append(self.buf.popleft())
        if self.buf:
            self.buf.popleft()
        marks_spaces = []
        for dt, lvl in local:
            is_mark = (lvl == 0) if self.active_low else (lvl == 1)
            marks_spaces.append((dt, 'M' if is_mark else 'S'))
        while marks_spaces and marks_spaces[0][1] == 'S':
            marks_spaces.pop(0)
        seq = [int(dt) for dt, _ in marks_spaces]
        if len(seq) < 4:
            return None
        return seq

    def _decode_nec(self, seq):
        if len(seq) < 4:
            return None
        mark0, space0 = seq[0], seq[1]
        if in_range(mark0, NEC_HDR_MARK) and in_range(space0, NEC_RPT_SPACE):
            rpt = IRFrame("NEC", repeat=True, raw=seq)
            if self._last_nec:
                rpt.address = self._last_nec.address
                rpt.command = self._last_nec.command
                rpt.bits = self._last_nec.bits
                rpt.value = self._last_nec.value
            return rpt
        if not (in_range(mark0, NEC_HDR_MARK) and in_range(space0, NEC_HDR_SPACE)):
            return None
        bits = []
        i = 2
        while i + 1 < len(seq):
            m = seq[i]
            s = seq[i + 1]
            if in_range(m, NEC_BIT_MARK):
                if in_range(s, NEC_ONE_SPACE):
                    bits.append(1)
                elif in_range(s, NEC_ZERO_SPACE):
                    bits.append(0)
                else:
                    if in_range(m, NEC_TRAIL_MARK) and i+1 == len(seq)-1:
                        break
                    return None
                i += 2
            else:
                if in_range(m, NEC_TRAIL_MARK) and (i == len(seq)-1):
                    break
                return None
        if len(bits) not in (NEC_FRAME_BITS,):
            return None
        value = 0
        for idx, b in enumerate(bits):
            value |= (b & 1) << idx
        addr     =  value        & 0xFF
        addr_inv = (value >> 8)  & 0xFF
        cmd      = (value >> 16) & 0xFF
        cmd_inv  = (value >> 24) & 0xFF
        frame = IRFrame("NEC",
                        address=addr,
                        command=cmd,
                        bits=len(bits),
                        value=value,
                        repeat=False,
                        raw=seq)
        self._last_nec = frame
        return frame

    def _decode_sirc(self, seq):
        if len(seq) < 4:
            return None
        mark0, space0 = seq[0], seq[1]
        if not (in_range(mark0, SIRC_HDR_MARK) and in_range(space0, SIRC_HDR_SPACE)):
            return None
        bits = []
        i = 2
        while i + 1 < len(seq):
            m = seq[i]
            s = seq[i + 1]
            if not in_range(s, SIRC_BIT_SPACE):
                return None
            if in_range(m, SIRC_ONE_MARK):
                bits.append(1)
            elif in_range(m, SIRC_ZERO_MARK):
                bits.append(0)
            else:
                return None
            i += 2
        if len(bits) not in (12, 15, 20):
            return None
        value = 0
        for idx, b in enumerate(bits):
            value |= (b & 1) << idx
        if len(bits) == 12:
            cmd = value & 0x7F
            addr = (value >> 7) & 0x1F
        elif len(bits) == 15:
            cmd = value & 0x7F
            addr = (value >> 7) & 0xFF
        else:
            cmd = value & 0x7F
            addr = (value >> 7) & 0xFFFF
        return IRFrame("SIRC", address=addr, command=cmd, bits=len(bits), value=value, raw=seq)

    def read(self, timeout_ms=0):
        t0 = time.ticks_ms()
        while True:
            seq = self._drain_frame()
            if seq:
                for decoder in (self._decode_nec, self._decode_sirc):
                    frame = decoder(seq)
                    if frame:
                        if self.cb:
                            try:
                                self.cb(frame)
                            except:
                                pass
                        return frame
                return IRFrame("UNKNOWN", raw=seq)
            if timeout_ms <= 0:
                return None
            if time.ticks_diff(time.ticks_ms(), t0) > timeout_ms:
                return None
            time.sleep_ms(1)

    def clear_buffer(self):
        self.buf.clear()

    def set_callback(self, cb):
        self.cb = cb
```

</details>

위 라이브러리 코드는 다음 명령어를 통해 TiCLE Lite에 설치시켜줄 수 있습니다.

```sh
upy put ir_remote.py lib/
```

아래는 IR 신호를 받는 클래스에 대한 API 문서입니다.

**IRReceiver 클래스**
- `IRReceiver(pin, active_low=True, buf_len=256, gap_us=None, cb=None)` : IR 수신 핀에 인터럽트를 걸어 신호 간격을 버퍼에 기록한 뒤, NEC/SIRC 프레임으로 파싱하도록 초기화합니다. cb에 콜백함수를 입력하면 프레임이 해석될 때마다 즉시 호출합니다.
- `read(timeout_ms=0) -> IRFrame | None` : 버퍼에서 완성된 프레임을 하나 읽어 NEC/SIRC 중 해석 가능한 프로토콜이면 `IRFrame`을 반환합니다. timeout_ms 동안 프레임이 없으면 None을 반환합니다.
- `clear_buffer() -> None` : 내부 수신 버퍼를 모두 비우고 새로 수신하도록 준비합니다.
- `set_callback(cb) -> None` : 프레임 해석 시 호출할 콜백을 설정합니다. cb(frame) 형태로 호출되며, 이미 등록된 콜백을 교체하실 수 있습니다.

`IRReceiver` 클래스에서 `read()` 함수 호출 시 `IRFrame` 클래스를 반환하는데, 이 `IRFrame` 클래스는 다음 정보를 가지고 있습니다.
- `protocol` : 프로토콜 (NEC/SIRC)
- `address` : 주소
- `command` : 명령어

위 클래스를 사용하여 아래 예제를 작성해볼 수 있습니다.

```py
# ir.py
from ir_remote import IRReceiver

ir = IRReceiver(pin=17)

print("Listening for IR signals...")

while True:
    frame = ir.read(timeout_ms=200)
    if not frame:
        continue

    if frame.protocol == "NEC":
        print("NEC Frame   cmd=0x%02X  addr=0x%02X" % (frame.command, frame.address))
    else:
        print("Unknown Frame  len=%d" % len(frame.raw))
```

## PIO

PIO(Programmable I/O)는 TiCLE의 RP2350 마이크로컨트롤러에 내장된 독립적인 입출력 처리 장치로, 일반적인 GPIO보다 훨씬 정밀하고 유연한 신호 제어를 가능하게 합니다. PIO는 간단한 명령어로 구성된 전용 프로그램을 실행하여, CPU의 개입 없이도 일정한 타이밍으로 데이터를 송수신하거나 특정 신호 패턴을 생성할 수 있습니다.

RP2350에는 두 개의 PIO 블록이 있으며, 각 블록은 네 개의 상태머신(State Machine)을 가지고 있어 동시에 여러 입출력 동작을 병렬로 수행할 수 있습니다. 이러한 구조를 통해 WS2812 LED 제어나, 독자적인 통신 프로토콜, 고속 파형 출력 등과 같이 정밀한 타이밍이 필요한 작업을 효율적으로 처리할 수 있습니다.

결과적으로 PIO는 RP2350을 단순한 마이크로컨트롤러가 아닌, 작은 범용 하드웨어 제어 장치로 확장시켜주는 핵심 기능이라 할 수 있습니다.

### WS2812

WS2812는 각 LED마다 고유한 데이터 입력 핀을 가진 개별 제어형 RGB LED로, 하나의 데이터 라인으로 여러 LED를 직렬로 연결해 제어할 수 있는 특징이 있습니다. 그러나 WS2812는 정확한 타이밍(나노초 단위)의 신호를 요구하기 때문에, 일반적인 GPIO 제어나 소프트웨어 루프로는 안정적인 구동이 어렵습니다.

이때 RP2350의 PIO를 사용하면, CPU의 간섭 없이 하드웨어 수준에서 정확한 주기와 신호 폭을 유지하며 데이터를 전송할 수 있습니다. 즉, PIO가 일정한 속도로 LED 데이터 스트림을 생성하고 CPU는 다른 작업을 수행할 수 있어, 다수의 WS2812 LED를 효율적이고 안정적으로 제어할 수 있습니다.

아래 사진과 같이 위치한 WS2812를 제어해봅니다.

![ws2812]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'ws2812.py' 라는 이름으로 저장합니다.

```py
# ws2812.py
from machine import Pin
from rp2 import PIO, StateMachine, asm_pio
import time

WIDTH, HEIGHT = 16, 16

@asm_pio(
    sideset_init=PIO.OUT_LOW,
    out_shiftdir=PIO.SHIFT_LEFT,
    autopull=True,
    pull_thresh=24
)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label("bitloop")
    out(x, 1)               .side(0) [T3 - 1]
    jmp(not_x, "do_zero")   .side(1) [T1 - 1]
    jmp("bitloop")          .side(1) [T2 - 1]
    label("do_zero")
    nop()                   .side(0) [T2 - 1]
    wrap()

class WS2812MatrixPIO:
    def __init__(self, pin, width=WIDTH, height=HEIGHT, sm_id=0, freq=8_000_000):
        self.width, self.height = width, height
        self.buf = bytearray(width * height * 3)
        self.sm = StateMachine(sm_id, ws2812, freq=freq, sideset_base=Pin(pin))
        self.sm.active(1)

    def _idx(self, x, y):
        return (y * self.width + x) * 3

    def __setitem__(self, xy, rgb):
        x, y = xy
        r, g, b = rgb
        i = self._idx(x, y)
        self.buf[i + 0] = g & 0xFF
        self.buf[i + 1] = r & 0xFF
        self.buf[i + 2] = b & 0xFF

    def clear(self):
        for i in range(len(self.buf)):
            self.buf[i] = 0

    def show(self):
        mv = memoryview(self.buf)
        for i in range(0, len(mv), 3):
            v = (mv[i] << 16) | (mv[i + 1] << 8) | mv[i + 2]
            self.sm.put(v, 8)
        time.sleep_us(300)

matrix = WS2812MatrixPIO(pin=6, width=16, height=16)
matrix.clear()
matrix[3, 4] = (255, 0, 0)
matrix[4, 4] = (0, 255, 0)
matrix[5, 4] = (0, 0, 255)
matrix.show()
```

각 픽셀의 색상을 지정한 뒤, PIO를 통해 일정한 타이밍으로 데이터를 전송하여 LED의 색을 정확하게 표시합니다.

프로그램은 먼저 PIO 어셈블리로 WS2812 통신 규격에 맞는 신호를 생성합니다. 이 신호는 LED가 요구하는 나노초 단위의 정밀한 펄스 폭을 유지해야 하므로, 일반적인 GPIO 제어 대신 PIO를 사용합니다. 이후 `WS2812MatrixPIO` 클래스는 LED 매트릭스를 위한 버퍼를 생성하고, 각 좌표에 해당하는 색상 데이터를 RGB 형태로 저장합니다. `show()` 함수가 호출되면 이 데이터가 순서대로 전송되어 매트릭스에 표시됩니다.

이와 같은 구조를 통해 CPU는 복잡한 타이밍 제어에 관여하지 않고도 안정적으로 다수의 LED를 구동할 수 있습니다. 실습을 실행하면 특정 좌표의 LED가 빨강, 초록, 파랑으로 점등되는 것을 확인할 수 있습니다.

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 이후 특정 위치의 WS2812 LED 픽셀에 대해 색상이 들어옵니다. 

```sh
upy ws2812.py
```

이렇게 해서 pio를 통해 WS2812를 제어할 수 있습니다. 하지만 원활한 프로젝트 개발을 위해 이 코드 또한 추상화시킨 라이브러리 파일을 제공해드립니다.

<details>
<summary>ws2812.py</summary>

```python
import math, utime, array, gc, machine, micropython, rp2

gc.threshold(20480)

@rp2.asm_pio(sideset_init=rp2.PIO.OUT_LOW, out_shiftdir=rp2.PIO.SHIFT_LEFT, autopull=True, pull_thresh=24)
def __ws2812_pio():
    T1, T2, T3 = 2, 5, 3
    wrap_target()
    label("bitloop")
    out(x, 1)               .side(0)    [T3 - 1]
    jmp(not_x, "do_zero")   .side(1)    [T1 - 1]
    jmp("bitloop")          .side(1)    [T2 - 1]
    label("do_zero")
    nop()                   .side(0)    [T2 - 1]
    wrap()

class WS2812Matrix:
    def __init__(self, pin_sm_pairs, panel_width=16, panel_height=16,
                 grid_width=1, grid_height=1, zigzag=False, origin="top_left",
                 brightness=0.25):
        if origin not in ("top_left", "top_right", "bottom_left", "bottom_right"):
            raise ValueError("origin must be top_left/top_right/bottom_left/bottom_right")

        for _, sm_id in pin_sm_pairs:
            if not (0 <= sm_id <= 11):
                raise ValueError("State machine ID out of range (0-11)")

        self.__panel_width = int(panel_width)
        self.__panel_height = int(panel_height)
        self.__grid_width = int(grid_width)
        self.__grid_height = int(grid_height)

        self._fb_width = self.__panel_width * self.__grid_width
        self._fb_height = self.__panel_height * self.__grid_height
        self._fb_length = self._fb_width * self._fb_height
        self._fb = array.array("I", [0] * self._fb_length)
        self._fb_dirty = False

        self.__zigzag = bool(zigzag)
        self.__origin = origin

        self.brightness = float(brightness)

        self.__sms = []
        self.__tx_bufs = []

        self.__panels_per_sm = math.ceil((self.__grid_width * self.__grid_height) / len(pin_sm_pairs))
        self.__pixels_per_panel = self.__panel_width * self.__panel_height

        for pin_no, sm_id in pin_sm_pairs:
            try:
                pin = machine.Pin(pin_no, machine.Pin.OUT, machine.Pin.PULL_DOWN)
                sm = rp2.StateMachine(sm_id, __ws2812_pio, freq=8_000_000, sideset_base=pin)
                sm.active(1)
                self.__sms.append(sm)
                buf_len = self.__pixels_per_panel * self.__panels_per_sm
                self.__tx_bufs.append(array.array("I", [0] * buf_len))
            except OSError as e:
                for sm2 in self.__sms:
                    try:
                        sm2.active(0)
                    except:
                        pass
                raise OSError("Failed init pin {} / SM {}: {}".format(pin_no, sm_id, e))

        self.__sm_ids = [sm_id for _, sm_id in pin_sm_pairs]
        self.__dmas = [rp2.DMA() for _ in self.__sms]

        self.__build_pix_maps()

    class _PixelView:
        def __init__(self, parent, x, y):
            self._parent = parent
            self._x = x
            self._y = y

        @property
        def value(self):
            fb = self._parent._fb
            w = self._parent._fb_width
            packed = fb[self._y * w + self._x]
            g = (packed >> 24) & 0xFF
            r = (packed >> 16) & 0xFF
            b = (packed >> 8) & 0xFF
            return (r, g, b)

        @value.setter
        def value(self, color):
            self._parent._set_pixel(self._x, self._y, color)

    def __getitem__(self, pos):
        if isinstance(pos, tuple) and len(pos) == 2:
            x, y = pos
            if not (0 <= x < self._fb_width and 0 <= y < self._fb_height):
                raise IndexError("Pixel coordinates out of bounds")
            return WS2812Matrix._PixelView(self, x, y)
        else:
            raise TypeError("Index must be a tuple of (x, y)")

    @micropython.native
    def _set_pixel(self, x, y, color):
        r, g, b = self.__normalize_color(color)
        packed = self.__pack_grb(r, g, b)
        if 0 <= x < self._fb_width and 0 <= y < self._fb_height:
            self._fb[y * self._fb_width + x] = packed
            self._fb_dirty = True

    @property
    def width(self):
        return self._fb_width

    @property
    def height(self):
        return self._fb_height

    @property
    def brightness(self):
        return self.__brightness

    @brightness.setter
    def brightness(self, value):
        self.__brightness = max(0.0, min(value, 1.0))
        self.__btab = bytes(int(i * self.__brightness + 0.5) for i in range(256))

    @micropython.native
    def update(self, wait=True):
        dma_busy = any(dma.active() for dma in self.__dmas)
        if dma_busy and not wait:
            return
        if dma_busy and wait:
            while any(dma.active() for dma in self.__dmas):
                pass

        if self._fb_dirty:
            self.__flush_fb_to_txb()
            self._fb_dirty = False

        for sm_id, sm, src, dma in zip(self.__sm_ids, self.__sms, self.__tx_bufs, self.__dmas):
            if not dma.active():
                ctrl = dma.pack_ctrl(size=2, inc_write=False, treq_sel=self.__pio_dreq(sm_id), bswap=False)
                dma.config(read=src, write=sm, count=len(src), ctrl=ctrl, trigger=True)

        if wait:
            while any(dma.active() for dma in self.__dmas):
                pass

    def clear(self):
        self.fill(0)
        self.update(True)

    @micropython.native
    def fill(self, color):
        r, g, b = self.__normalize_color(color)
        packed = self.__pack_grb(r, g, b)
        self.__fill32(self._fb, 0, packed, self._fb_length)
        self._fb_dirty = True

    def deinit(self):
        self.clear()
        utime.sleep_ms(50)
        for sm in self.__sms:
            sm.active(0)

    @micropython.native
    def draw_line(self, x0, y0, x1, y1, color):
        r, g, b = self.__normalize_color(color)
        packed = self.__pack_grb(r, g, b)
        w = self._fb_width
        h = self._fb_height
        fb = self._fb

        if y0 == y1:
            y = y0
            if 0 <= y < h:
                if x0 > x1:
                    x0, x1 = x1, x0
                x0 = max(0, x0)
                x1 = min(w - 1, x1)
                if x0 <= x1:
                    span = x1 - x0 + 1
                    base = y * w + x0
                    self.__fill32(fb, base, packed, span)
                    self._fb_dirty = True
            return

        if x0 == x1:
            x = x0
            if not (0 <= x < w):
                return
            if y0 > y1:
                y0, y1 = y1, y0
            y0 = max(0, y0)
            y1 = min(h - 1, y1)
            if y0 > y1:
                return
            span = y1 - y0 + 1
            offset = y0 * w + x
            self.__fill32(fb, offset, packed, span)
            self._fb_dirty = True
            return

        dx = abs(x1 - x0)
        sx = 1 if x0 < x1 else -1
        dy = -abs(y1 - y0)
        sy = 1 if y0 < y1 else -1
        err = dx + dy

        while True:
            if 0 <= x0 < w and 0 <= y0 < h:
                fb[y0 * w + x0] = packed
            if x0 == x1 and y0 == y1:
                break
            e2 = err << 1
            if e2 >= dy:
                err += dy
                x0  += sx
            if e2 <= dx:
                err += dx
                y0  += sy
        self._fb_dirty = True

    @micropython.native
    def draw_line_polar(self, cx, cy, length, angle_deg, color):
        w, h = self._fb_width, self._fb_height
        fb = self._fb
        half = length >> 1
        if half <= 0:
            return
        angle = angle_deg % 360

        r, g, b = self.__normalize_color(color)
        packed = self.__pack_grb(r, g, b)

        if angle % 90 == 0:
            if angle == 0 or angle == 180:
                y = cy
                if not (0 <= y < h):
                    return
                x0 = cx - half
                x1 = cx + half
                if angle == 180:
                    x0, x1 = x1, x0
                if x0 > x1:
                    x0, x1 = x1, x0
                x0 = max(0, x0)
                x1 = min(w - 1, x1)
                if x0 <= x1:
                    span = x1 - x0 + 1
                    base = y * w + x0
                    fb[base: base + span] = array.array('I', [packed] * span)
                    self._fb_dirty = True
                return
            else:
                x = cx
                if not (0 <= x < w):
                    return
                y0 = cy - half
                y1 = cy + half
                if angle == 270:
                    y0, y1 = y1, y0
                if y0 > y1:
                    y0, y1 = y1, y0
                y0 = max(0, y0)
                y1 = min(h - 1, y1)
                if y0 <= y1:
                    for py in range(y0, y1 + 1):
                        fb[py * w + x] = packed
                    self._fb_dirty = True
                return

        rad  = math.radians(angle)
        dxh  = int(round(math.cos(rad) * half))
        dyh  = int(round(math.sin(rad) * half))
        x0 = cx - dxh; y0 = cy - dyh
        x1 = cx + dxh; y1 = cy + dyh
        if (x0 < 0 and x1 < 0) or (x0 >= w and x1 >= w): return
        if (y0 < 0 and y1 < 0) or (y0 >= h and y1 >= h): return
        self.draw_line(x0, y0, x1, y1, color)

    @micropython.native
    def draw_rect(self, x, y, w, h, outline, fill=None):
        if w <= 0 or h <= 0:
            return
        x1, y1 = x, y
        x2, y2 = x + w - 1, y + h - 1
        dw, dh = self._fb_width, self._fb_height
        fb = self._fb
        pix_out = self.__pack_grb(*self.__normalize_color(outline))
        pix_fill = (self.__pack_grb(*self.__normalize_color(fill)) if fill is not None else None)

        def hspan(y_row, xa, xb, packed):
            if not (0 <= y_row < dh):
                return
            if xb < 0 or xa >= dw:
                return
            if xa < 0:
                xa = 0
            if xb >= dw:
                xb = dw - 1
            if xa > xb:
                return
            self.__fill32(fb, y_row*dw + xa, packed, xb - xa + 1)

        hspan(y1, x1, x2, pix_out)
        if y2 != y1:
            hspan(y2, x1, x2, pix_out)

        if w >= 2:
            xa, xb = x1, x2
            for py in range(max(y1, 0)+1, min(y2, dh-1)):
                row = py * dw
                if 0 <= xa < dw:
                    fb[row + xa] = pix_out
                if 0 <= xb < dw and xb != xa:
                    fb[row + xb] = pix_out

        if pix_fill is not None and w > 2 and h > 2:
            fill_xa = x1 + 1
            fill_xb = x2 - 1
            for py in range(max(y1+1, 0), min(y2, dh-1)):
                hspan(py, fill_xa, fill_xb, pix_fill)

        self._fb_dirty = True

    @micropython.native
    def draw_rect_polar(self, cx, cy, w, h, angle_deg, outline, fill=None):
        if w <= 0 or h <= 0:
            return
        if angle_deg % 90 == 0:
            self.draw_rect(cx - (w >> 1), cy - (h >> 1), w, h, outline, fill=fill)
            return

        half_w = (w - 1) / 2.0
        half_h = (h - 1) / 2.0
        vx = (-half_w, +half_w, +half_w, -half_w)
        vy = (-half_h, -half_h, +half_h, +half_h)

        rad = math.radians(angle_deg)
        ca, sa = math.cos(rad), math.sin(rad)

        def rot(ix, iy):
            return cx + ix * ca - iy * sa, cy + ix * sa + iy * ca

        pts = [rot(vx[i], vy[i]) for i in range(4)]

        fb = self._fb
        dw, dh = self._fb_width, self._fb_height
        p_out = self.__pack_grb(*self.__normalize_color(outline))
        p_fill = (self.__pack_grb(*self.__normalize_color(fill)) if fill is not None else None)

        tris = [(pts[0], pts[1], pts[2]), (pts[0], pts[2], pts[3])]

        def edge_x(y_scan, v0, v1):
            x0, y0 = v0;  x1, y1 = v1
            if y0 == y1:
                return None
            if y0 > y1:
                x0, y0, x1, y1 = x1, y1, x0, y0
            if not (y0 <= y_scan < y1):
                return None
            t = (y_scan - y0) / (y1 - y0)
            return x0 + t * (x1 - x0)

        y_min = max(0, int(math.ceil(min(p[1] for p in pts))))
        y_max = min(dh - 1, int(math.floor(max(p[1] for p in pts))))

        if p_fill is not None:
            for py in range(y_min, y_max + 1):
                xs = []
                for v0, v1, v2 in tris:
                    for e0, e1 in ((v0, v1), (v1, v2), (v2, v0)):
                        xx = edge_x(py + 0.5, e0, e1)
                        if xx is not None:
                            xs.append(xx)
                if len(xs) < 2:
                    continue
                xs.sort()
                xa = int(math.ceil(xs[0])) + 1
                xb = int(math.floor(xs[-1])) - 1
                if xa <= xb:
                    if xa < 0: xa = 0
                    if xb >= dw: xb = dw - 1
                    if xa <= xb:
                        self.__fill32(fb, py * dw + xa, p_fill, xb - xa + 1)

        def put(px, py):
            if 0 <= px < dw and 0 <= py < dh:
                fb[py * dw + px] = p_out

        for py in range(y_min, y_max + 1):
            xs = []
            for v0, v1, v2 in tris:
                for e0, e1 in ((v0, v1), (v1, v2), (v2, v0)):
                    xx = edge_x(py + 0.5, e0, e1)
                    if xx is not None:
                        xs.append(xx)
            if len(xs) < 2:
                continue
            xs.sort()
            xl = int(math.floor(xs[0] + 0.5))
            xr = int(math.floor(xs[-1] + 0.5))
            put(xl, py)
            if xr != xl:
                put(xr, py)

        self._fb_dirty = True

    @micropython.native
    def draw_ellipse(self, cx, cy, rx, ry=None, outline=(255, 255, 255), fill=None, angle_deg=0.0):
        if ry is None:
            ry = rx
        if rx <= 0 or ry <= 0:
            return

        dw, dh = self._fb_width, self._fb_height
        fb = self._fb
        p_edge = self.__pack_grb(*self.__normalize_color(outline))
        p_fill = (self.__pack_grb(*self.__normalize_color(fill)) if fill is not None else None)

        if angle_deg == 0.0:
            rx2, ry2 = rx * rx, ry * ry
            two_rx2  = rx2 << 1
            two_ry2  = ry2 << 1
            x, y = 0, ry
            dx, dy = 0, two_rx2 * y
            d1 = ry2 - rx2 * ry + (rx2 >> 2)

            def pset(px, py):
                if 0 <= px < dw and 0 <= py < dh:
                    fb[py * dw + px] = p_edge

            while dx < dy:
                if p_fill is not None:
                    xa, xb = cx - x, cx + x
                    if xa < 0: xa = 0
                    if xb >= dw: xb = dw - 1
                    if xa <= xb:
                        span = xb - xa + 1
                        self.__fill32(fb, (cy + y) * dw + xa, p_fill, span)
                        self.__fill32(fb, (cy - y) * dw + xa, p_fill, span)

                pset(cx + x, cy + y);  pset(cx - x, cy + y)
                pset(cx + x, cy - y);  pset(cx - x, cy - y)
                x  += 1
                dx += two_ry2
                if d1 < 0:
                    d1 += dx + ry2
                else:
                    y  -= 1
                    dy -= two_rx2
                    d1 += dx - dy + ry2

            d2 = (ry2 * (x + 0.5)**2) + (rx2 * (y - 1)**2) - rx2 * ry2
            while y >= 0:
                if p_fill is not None:
                    xa, xb = cx - x, cx + x
                    if xa < 0: xa = 0
                    if xb >= dw: xb = dw - 1
                    if xa <= xb:
                        span = xb - xa + 1
                        self.__fill32(fb, (cy + y) * dw + xa, p_fill, span)
                        self.__fill32(fb, (cy - y) * dw + xa, p_fill, span)

                pset(cx + x, cy + y);  pset(cx - x, cy + y)
                pset(cx + x, cy - y);  pset(cx - x, cy - y)
                y -= 1
                if d2 > 0:
                    d2 += rx2 - (two_rx2 * y)
                else:
                    x += 1
                    d2 += two_ry2 * x + rx2 - two_rx2 * y

            self._fb_dirty = True
            return

        th  = math.radians(angle_deg)
        ct, st = math.cos(th), math.sin(th)
        inv_rx2, inv_ry2 = 1 / (rx * rx), 1 / (ry * ry)
        A = ct * ct * inv_rx2 + st * st * inv_ry2
        B = 2 * ct * st * (inv_rx2 - inv_ry2)
        C = st * st * inv_rx2 + ct * ct * inv_ry2
        h_bound = abs(rx * st) + abs(ry * ct)
        y0 = max(0, int(cy - h_bound) - 1)
        y1 = min(dh - 1, int(cy + h_bound) + 1)

        for py in range(y0, y1 + 1):
            dy = py - cy
            By = B * dy
            K  = C * dy * dy - 1
            D  = By * By - 4 * A * K
            if D < 0:
                continue
            sqrtD = math.sqrt(D)
            xL = (-By - sqrtD) / (2 * A)
            xR = (-By + sqrtD) / (2 * A)
            oxl = int(math.ceil(cx + xL))
            oxr = int(math.floor(cx + xR))
            if oxr < 0 or oxl >= dw:
                continue
            xl = max(0, oxl)
            xr = min(dw - 1, oxr)
            if xl > xr:
                continue
            if p_fill is not None:
                self.__fill32(fb, py * dw + xl, p_fill, xr - xl + 1)
            if 0 <= oxl < dw:
                fb[py * dw + oxl] = p_edge
            if oxr != oxl and 0 <= oxr < dw:
                fb[py * dw + oxr] = p_edge

        self._fb_dirty = True

    def draw_circle(self, cx, cy, r, color, fill=None):
        self.draw_ellipse(cx, cy, r, r, color, fill=fill, angle_deg=0.0)

    @micropython.viper
    def __fill32(self, buf: ptr32, off: int, value: uint, count: int):
        i: int = 0
        while i < count:
            buf[off + i] = value
            i += 1

    @micropython.viper
    def __flush_fb_to_txb(self):
        fb = ptr32(self._fb)
        map_sm = ptr8(self.__pix_map_sm)
        map_idx = ptr16(self.__pix_map_idx)
        bufs = self.__tx_bufs
        length = int(self._fb_length)
        i = 0
        while i < length:
            sm = int(map_sm[i])
            idx = int(map_idx[i])
            bufs[sm][idx] = fb[i]
            i += 1

    @micropython.native
    def __build_pix_maps(self):
        dw = self._fb_width
        dh = self._fb_height
        n = dw * dh
        sm_t = array.array("B", [0] * n)
        idx_t = array.array("H", [0] * n)
        for y in range(dh):
            base = y * dw
            for x in range(dw):
                sm_i, bi = self.__coord_to_index(x, y)
                i = base + x
                sm_t[i] = sm_i
                idx_t[i] = bi
        self.__pix_map_sm = sm_t
        self.__pix_map_idx = idx_t

    @micropython.native
    def __coord_to_index(self, x, y):
        if not (0 <= x < self._fb_width and 0 <= y < self._fb_height):
            raise IndexError("pixel out of range")

        panel_col = x // self.__panel_width
        panel_row = y // self.__panel_height
        panel_id = panel_row * self.__grid_width + panel_col

        lx = x % self.__panel_width
        ly = y % self.__panel_height
        if self.__origin.startswith("bottom"):
            ly = self.__panel_height - 1 - ly
        if self.__origin.endswith("right"):
            lx = self.__panel_width - 1 - lx
        if self.__zigzag and (ly % 2):
            lx = self.__panel_width - 1 - lx

        sm_idx = panel_id // self.__panels_per_sm
        local_id = panel_id % self.__panels_per_sm
        buf_idx = local_id * self.__pixels_per_panel + ly * self.__panel_width + lx
        return sm_idx, buf_idx

    @micropython.native
    def __pack_grb(self, r, g, b):
        bt = self.__btab
        return (bt[g] << 24) | (bt[r] << 16) | (bt[b] << 8)

    @micropython.native
    def __normalize_color(self, color):
        if isinstance(color, (tuple, list)):
            if len(color) != 3:
                raise ValueError("Color tuple/list must have 3 elements")
            r, g, b = color
            if not (0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255):
                raise ValueError("RGB must be 0-255 ints")
            return int(r), int(g), int(b)
        elif isinstance(color, int):
            if not (0 <= color <= 0xFFFFFF):
                raise ValueError("hex 0x000000-0xFFFFFF")
            return (color >> 16) & 0xFF, (color >> 8) & 0xFF, color & 0xFF
        else:
            raise TypeError("Color must be tuple/list/int")

    @micropython.native
    def __pio_dreq(self, sm_id):
        if sm_id < 4:
            pio = 0
        elif sm_id < 8:
            pio = 1
        elif sm_id < 12:
            pio = 2
        else:
            raise ValueError("SM id out of range")
        return (pio << 3) | (sm_id & 0x03)
```

</details>



## ADC

ADC란 'Analog to Digital Conversion' 의 약자로써, 문자 그대로 아날로그 신호를 디지털 신호로 변환시켜주는 장치를 의미합니다. 디지털 신호만 처리하는 컴퓨터와는 다르게 우리 세상 속에는 수없이 많은 아날로그 신호들이 있습니다. 대표적인 예로 빛을 들자면, High/Low만 구분할 수 있는 디지털과는 달리 빛의 양, 즉 조도량은 High/Low로 표현할 수 없습니다. 이와 같은 아날로그 신호들은 ADC를 거쳐 디지털 신호로 변환된 뒤 그 값을 확인시켜줄 수 있게 해줍니다.

Micropython에선 `machine` 라이브러리의 `ADC` 클래스를 사용하여 제어합니다.

### VR

VR이란 자기 저항의 변화를 측정하는 센서로써, 다이얼이 돌려진 값을 정확하게 파악할 수 있는 센서입니다. 아래 사진과 같이 위치한 VR을 제어해봅니다.

![vr]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'vr.py' 라는 이름으로 저장합니다.

```python
# vr.py
from machine import Pin, ADC
import utime

vr_pin = 28

vr = ADC(Pin(vr_pin))

while True:
    print(f"VR : {vr.read_u16()}")
    utime.sleep_ms(500)
```

실질적으로 ADC를 통해 센서값을 읽는 함수는 `read_u16()` 함수입니다. 이 함수는 3.3V를 16bit(0~65535)로 변환시켜주어 디지털 값으로 반환시켜줍니다.

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 다이얼의 돌림 상태에 따라 프로그램 출력값이 달라지는 것을 확인할 수 있습니다.

```
VR : 65535
VR : 65535
VR : 55181
VR : 23173
VR : 19508
VR : 19764
```

### CdS

CdS란 조도량을 측정할 수 있는 센서입니다. 아래 사진과 같이 위치한 Cds를 제어해봅니다.

![cds]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'cds.py' 라는 이름으로 저장합니다.

```python
# cds.py
from machine import Pin, ADC
import utime

cds_pin = 27

cds = ADC(Pin(cds_pin))

while True:
    print(f"CDS : {cds.read_u16()}")
    utime.sleep_ms(500)
```

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 주변 환경의 밝기 상태에 따라 프로그램 출력값이 달라지는 것을 확인할 수 있습니다.

```sh
upy cds.py
```

터미널 출력 결과

```
CDS : 50892
CDS : 50700
CDS : 50636
CDS : 50508
```

### MIC

MIC란 주변 소음량을 측정할 수 있는 센서입니다. 아래 사진과 같이 위치한 MIC를 제어해봅니다.

![mic]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'mic.py' 라는 이름으로 저장합니다.

```py
# mic.py
from machine import Pin, ADC
import utime

mic_pin = 26

mic = ADC(Pin(mic_pin))

while True:
    print(f"MIC : {mic.read_u16()}")
    utime.sleep_ms(250)
```

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 주변 환경의 소음 크기에 따라 프로그램 출력값이 달라지는 것을 확인할 수 있습니다.

```sh
upy mic.py
```

터미널 출력 결과

```
MIC : 29015
MIC : 25670
MIC : 26038
MIC : 23653
MIC : 26134
```


## PWM

펄스 폭 변조(PWM Pulse Width Modulation)는 디지털 방식으로 다양한 아날로그 신호를 흉내 내는 기술로 HIGH와 LOW로 구성된 펄스에 HIGH 구간의 비율을 조절하는 것으로 설명할 수 있습니다.

PWM 신호를 정의하는 매개 변수는 주파수와 듀티 사이클입니다. 주파수는 펄스, 듀티 사이클은 펄스 폭에 해당하는 것으로 출력 장치의 전원에 주파수를 듀티 사이클로 순환시킨 PWM 출력을 전달하면, 출력 장치는 이를 정전압 아날로그 신호로 인식합니다. 

듀티 사이클은 HIGH 구간의 펄스 폭을 주기에 대한 백분율로 표현하는데, 주파수가 고정된 상태에서 듀티 사이클을 바꾸면 출력되는 평균 전압도 변합니다. 100% 듀티 사이클은 출력 레벨이 HIGH임을 의미하고 0% 듀티 사이클은 LOW임을 의미합니다. 50% 듀티 사이클은 출력 레벨이 HIGH와 LOW의 중간입니다. 60% 듀티 사이클은 출력을 60% 동안만 HIGH로 유지하므로 주기가 10 us (마이크로 초; 1 us = $1*10^{-6}$ 초)(100kHz)인 경우 6 us 동안 출력이 HIGH를 유지하며, HIGH일 때 최대 전압이 3.3V라면 평균 전압은 3.3V * 0.6 = 1.98V입니다. 

Micropython에서의 PWM 제어는 `machine` 라이브러리의 `PWM` 클래스를 사용하여 제어합니다.

### Piezo

아래 사진과 같이 위치한 Piezo를 제어해봅니다.

![piezo_buzzer]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'piezo.py' 라는 이름으로 저장합니다.

```python
# piezo.py
from machine import Pin, PWM
import utime

piezo = PWM(Pin(16))
piezo.freq(1000)

def tone(freq, duration_ms):
    piezo.freq(freq)
    piezo.duty_u16(32768)
    utime.sleep_ms(duration_ms)
    piezo.duty_u16(0)

melody = [262, 294, 330, 349, 392, 440, 494, 523]

while True:
    for f in melody:
        tone(f, 200)
        utime.sleep_ms(50)
```

각 음계에 해당하는 주파수는 다음과 같습니다. 4 옥타브 기준입니다.

| 음계 | 주파수 |
| --- | ----- |
| C(도) | 261.6256 |
| D(레) | 293.6648 |
| E(미) | 329.6276 |
| F(파) | 349.2282 |
| G(솔) | 391.9954 |
| A(라) | 440.0000 |
| B(시) | 493.6256 |

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 0.25초 단위로 음계가 올라가는 것을 확인할 수 있습니다.

```sh
upy piezo.py
```

### Servo Motor

아래 사진과 같이 위치한 Servo Motor를 제어해봅니다.

![servo]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'servo.py' 라는 이름으로 저장합니다.

```py
servo.py
from machine import Pin, PWM
import time

class Servo:
    def __init__(self, pin, freq=50):
        self.pwm = PWM(Pin(pin))
        self.pwm.freq(freq)
        self.min_duty = 1638
        self.max_duty = 8191

    def write(self, angle):
        angle = max(0, min(180, angle))
        duty = self.min_duty + (self.max_duty - self.min_duty) * angle // 180
        self.pwm.duty_u16(duty)

    def deinit(self):
        self.pwm.deinit()

servo = Servo(pin=2)
for ang in range(0, 181, 30):
    servo.write(ang)
    time.sleep(0.5)
for ang in range(180, -1, -30):
    servo.write(ang)
    time.sleep(0.5)
servo.deinit()
```

```py
# servo.py
from ticle.ext import ServoMotor
import utime

servo_pin = 2

servo = ServoMotor([servo_pin])

while True:
    for i in range(0,180):
        servo.angle = i
        utime.sleep_ms(100)
```

초기화 시 PWM 주파수를 50Hz로 설정하며, write(angle) 함수를 통해 0~180도 범위의 각도를 듀티비로 변환하여 제어합니다.

deinit() 함수는 PWM 출력을 종료하여 서보모터의 동작을 멈추며, 예제에서는 일정 각도로 움직였다가 다시 원위치로 돌아오도록 반복 동작합니다.

터미널에서 다음 명령어를 입력해 프로그램을 실행합니다. 서보모터의 각도가 0~180도에서 30도 간격으로 회전하는 것을 확인할 수 있습니다.


```sh
upy servo.py
```



## I2C

프로세서에 내장되어 근거리 칩 사이 통신에 사용되는 I2C Inter-Integrated Circuit는 동기식 직렬 통신 방식 중 하나로 풀업 저항이 연결된 SDA Serial Data와 SCL Serial Clock이라는 두 개의 반 이중 방식 Half-Duplex 오픈 드레인 버스 라인을 사용해 프로세서와 주변장치 사이에 데이터를 교환합니다. 

I2C는 마스터와 슬레이브 동작을 지원하며, 다중 마스터도 가능합니다. 각 디바이스는 송신기나 수신기로 동작합니다. I2C의 7bit 주소는 128개의 다른 슬레이브 주소까지 허용하며 400kHz까지의 데이터 전송 속도를 지닙니다.

Micropython에선 `machine` 라이브러리의 `I2C` 클래스를 사용하여 제어합니다. 단, 후술할 두 주변 장치는 복잡한 프로토콜과 제어 방식을 가지고 있어 직접 I2C 제어 구문을 작성하기에는 난이도가 높습니다. 따라서 아래 주변장치를 제어하는 건 `ticle.ext` 라이브러리로 대체합니다.

### LCD

아래 사진과 같이 위치한 LCD를 제어해봅니다.

![lcd]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'lcd.py' 라는 이름으로 저장합니다.

### IMU

아래 사진과 같이 위치한 IMU를 제어해봅니다.

![imu]()

VSCode 상에서 아래와 같이 코드를 작성한 후 'imu.py' 라는 이름으로 저장합니다.