# PBL 실습형 교재 문서 (Pico–Blynk 연동형)

## 1. 실습 주제

**Blynk 플랫폼을 이용한 버튼 입력 전송 및 원격 LCD 표시**

---

## 2. 프로젝트 개요

이 실습은 **Pico 보드 ↔ Blynk Cloud** 간 양방향 통신을 통해,

* 로컬 버튼 입력을 감지해 **Blynk 대시보드로 전송**하고
* Blynk 앱에서 입력된 문자열을 **LCD에 출력**합니다.

데이터 흐름:
**버튼 누름 → MQTT 업링크 → Blynk 표시 / Blynk 입력 → MQTT 다운링크 → LCD 출력**

---

## 3. 선행 작업 (작성 칸)

* Blynk Cloud 계정 및 Template 생성
* Auth Token 등록
* Blynk 앱/웹에서 `V0`, `V1` 등 가상핀 설정
* (Wi-Fi 연결 및 네트워크 확인 절차)

📸 (Blynk Dashboard UI 및 Pico 배선 사진 첨부 칸)

---

## 4. 개념 설명

* **BlynkDevice**: MQTT를 기반으로 Blynk Cloud와 데이터를 주고받는 인터페이스입니다.
* **Topic 구조**

  * `ds/btn` : 센서(버튼) → 클라우드 전송(업링크)
  * `downlink/ds/lcd` : 클라우드 → 장치(LCD 표시용)
* **디바운싱(Debounce)**: 버튼의 물리적 잡음을 제거하기 위해 입력 변화를 확인한 후 일정 시간(40ms) 동안 안정화합니다.
* **LCD 표시**: Blynk 앱에서 전송된 문자열을 수신하면 LCD를 지우고 텍스트를 새로 출력합니다.

---

## 5. Pico 코드

```python
from ticle import WifiManager
from blynk_mqtt import BlynkDevice
from machine import Pin
from hd44780_pcf8574 import HD44780_PCF8574
import utime

wifi = WifiManager()
wifi.connect("HBE_RSP", "hanback91!")

lcd = HD44780_PCF8574(scl=9, sda=8)
btn = Pin(18, Pin.IN)

def on_msg(topic, payload, ret, dup):
    try:
        t = topic.decode() if isinstance(topic, (bytes, bytearray)) else str(topic)
        if t == "downlink/ds/lcd":
            s = payload.decode() if isinstance(payload, (bytes, bytearray)) else str(payload)
            lcd.clear()
            utime.sleep_ms(2)
            lcd.text(s)
    except:
        pass

dev = BlynkDevice(
    template_id="TMPL6uWDgEYru",
    auth_token="8o8kSlOIZAmtatIlGfyg29FDRVrABRst",
    broker="blynk.cloud",
    firmware_version="0.0.1",
    on_message=on_msg,
)

dev.subscribe(b"downlink/ds/#")

last = btn.value()
last_change = utime.ticks_ms()
debounce_ms = 40

while True:
    dev.check_msg()

    v = btn.value()
    now = utime.ticks_ms()
    if v != last and utime.ticks_diff(now, last_change) >= debounce_ms:
        last = v
        last_change = now
        dev.publish(b"ds/btn", "1" if v else "0")

    utime.sleep_ms(10)
```

---

## 6. 코드 요약 (핵심 로직 중심)

### 6-1) Blynk 연결 설정

```python
wifi.connect("SSID", "PASSWORD")
dev = BlynkDevice(template_id="...", auth_token="...", broker="blynk.cloud")
dev.subscribe(b"downlink/ds/#")
```

* Blynk 클라우드와 MQTT 연결을 수립합니다.
* LCD용 다운링크(`downlink/ds/lcd`)를 구독합니다.

### 6-2) 다운링크 수신 → LCD 출력

```python
def on_msg(topic, payload, ret, dup):
    if topic.decode() == "downlink/ds/lcd":
        lcd.clear()
        lcd.text(payload.decode())
```

* Blynk 앱에서 전송된 문자열을 수신해 LCD에 표시합니다.

### 6-3) 버튼 디바운스 & 업링크 전송

```python
v = btn.value()
if v != last and ticks_diff(now, last_change) >= 40:
    dev.publish(b"ds/btn", "1" if v else "0")
```

* 버튼 상태가 안정적으로 변할 때만 `"1"` 또는 `"0"`을 Blynk로 보냅니다.
* 40ms의 디바운싱 시간으로 잡음을 제거합니다.

### 6-4) 이벤트 루프

```python
while True:
    dev.check_msg()      # 다운링크 메시지 수신 확인
    check_button_state() # 버튼 상태 감시
    utime.sleep_ms(10)
```

* 메시지 수신과 버튼 감지를 반복하며 실시간 통신을 유지합니다.

---

## 7. 결과 확인

* **버튼을 누르면** Blynk 앱의 가상핀 값이 `1`로 표시됩니다.
* **앱에서 텍스트를 전송**하면 LCD에 해당 문장이 즉시 출력됩니다.

📸 (Blynk 앱 버튼 상태 및 LCD 표시 결과 사진 첨부 칸)

---

## 8. 연습문제

1. 버튼을 여러 개 추가해 각각 다른 가상핀(`ds/btn1`, `ds/btn2` 등)으로 전송해보세요.
2. LCD의 텍스트를 두 줄로 표시하도록 `\n` 처리를 구현해보세요.
3. Blynk 대시보드에서 입력한 문자열을 주기적으로 갱신되도록 자동화(타이머 위젯) 기능을 추가해보세요.
