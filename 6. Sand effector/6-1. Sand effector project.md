# Sand effector

## 1. 실습 주제

기울기에 따라 픽셀이 중력 방향으로 흐르는 **Sand Effector** 만들기

## 2. 프로젝트 개요

장치의 기울기를 바탕으로 낙하 방향을 정하고, 16×16 LED 매트릭스의 픽셀이 그 방향으로 이동·쌓입니다. 화면 바깥에서 입자가 유입되어 계속 흐르는 효과가 납니다.

## 3. 개념 설명

* **낙하 규칙:** 빈 칸이면 한 칸 이동 → 막히면 대각선 한 칸 이동 시도 → 모두 막히면 정지.
* **방향 전환 안정화:** 지수평활로 흔들림을 줄이고, 일정 시간 같은 방향이 유지될 때만 낙하 방향을 변경.
* **가장자리 유입:** 화면 밖 입자는 현재 낙하 방향의 가장자리에서 들어옵니다.

## 4. 코드 전체

```python
from machine import I2C, Pin
from ticle.ext import WS2812Matrix
from mpu6050 import MPU6050
import utime, urandom

WIDTH=16; HEIGHT=16; NUM_PARTICLES=50
SAND_COLOR=(220,200,90); BACKGROUND_COLOR=(0,0,0)

matrix=WS2812Matrix([(3,1)])
matrix.clear()

i2c=I2C(0, scl=Pin(9), sda=Pin(8), freq=400000)
mpu=MPU6050(i2c)

def rand(n): return urandom.getrandbits(16)%n

class Particle:
    def __init__(self,x,y):
        self.x=int(x); self.y=int(y)

particles=[Particle(rand(WIDTH), -1-rand(6)) for _ in range(NUM_PARTICLES)]

gravity_dir='D'
ema_x=0.0; ema_y=0.0
ema_alpha=0.2
tilt_threshold=35.0
confirm_ms=150
hold_ms=500
last_switch_ms=utime.ticks_ms()
candidate_dir=None
candidate_since_ms=last_switch_ms

def is_empty(occ,x,y):
    return 0<=x<WIDTH and 0<=y<HEIGHT and occ[y][x] is None

def primary_delta(d):
    if d=='D': return (0,1)
    if d=='U': return (0,-1)
    if d=='L': return (-1,0)
    return (1,0)

def diagonal_deltas(d):
    if d=='D': return [(-1,1),(1,1)]
    if d=='U': return [(-1,-1),(1,-1)]
    if d=='L': return [(-1,-1),(-1,1)]
    return [(1,-1),(1,1)]

def entry_target(d,p):
    if d=='D' and p.y<0: return (p.x,0)
    if d=='U' and p.y>=HEIGHT: return (p.x,HEIGHT-1)
    if d=='L' and p.x>=WIDTH: return (WIDTH-1,p.y)
    if d=='R' and p.x<0: return (0,p.y)
    return None

def step_once(d):
    occ=[[None]*WIDTH for _ in range(HEIGHT)]
    for i,p in enumerate(particles):
        if 0<=p.x<WIDTH and 0<=p.y<HEIGHT:
            occ[p.y][p.x]=i
    nxt=[[None]*WIDTH for _ in range(HEIGHT)]
    if d=='D':
        y_range=range(HEIGHT-1,-1,-1); x_range=range(WIDTH)
    elif d=='U':
        y_range=range(HEIGHT); x_range=range(WIDTH)
    elif d=='L':
        y_range=range(HEIGHT-1,-1,-1); x_range=range(WIDTH)
    else:
        y_range=range(HEIGHT-1,-1,-1); x_range=range(WIDTH-1,-1,-1)
    for y in y_range:
        for x in x_range:
            i=occ[y][x]
            if i is None: continue
            dx,dy=primary_delta(d)
            nx,ny=x+dx,y+dy
            if is_empty(occ,nx,ny) and nxt[ny][nx] is None:
                nxt[ny][nx]=i
                continue
            diags=diagonal_deltas(d)
            if rand(2)==1:
                diags=list(reversed(diags))
            placed=False
            for sdx,sdy in diags:
                nx2,ny2=x+sdx,y+sdy
                if is_empty(occ,nx2,ny2) and nxt[ny2][nx2] is None:
                    nxt[ny2][nx2]=i
                    placed=True
                    break
            if not placed and nxt[y][x] is None:
                nxt[y][x]=i
    for idx,p in enumerate(particles):
        t=entry_target(d,p)
        if t:
            tx,ty=t
            if nxt[ty][tx] is None:
                nxt[ty][tx]=idx
                p.x,p.y=tx,ty
    for y in range(HEIGHT):
        for x in range(WIDTH):
            j=nxt[y][x]
            if j is not None:
                particles[j].x=x; particles[j].y=y
    for y in range(HEIGHT):
        for x in range(WIDTH):
            matrix[x,y]=BACKGROUND_COLOR
    for y in range(HEIGHT):
        for x in range(WIDTH):
            if nxt[y][x] is not None:
                matrix[x,y]=SAND_COLOR
    matrix.update()

while True:
    gz,gy,gx = mpu.read_gyro_data().values()
    ema_x=(1-ema_alpha)*ema_x+ema_alpha*gx
    ema_y=(1-ema_alpha)*ema_y+ema_alpha*gy
    dx=gx-ema_x
    dy=gy-ema_y

    ax=abs(dx); ay=abs(dy)
    desired=None
    if ax<tilt_threshold and ay<tilt_threshold:
        desired=None
    else:
        if ax>=ay:
            desired='U' if dx>0 else 'D'
        else:
            desired='L' if dy>0 else 'R'

    now=utime.ticks_ms()
    if desired!=candidate_dir:
        candidate_dir=desired
        candidate_since_ms=now
    else:
        if candidate_dir is not None:
            if utime.ticks_diff(now,candidate_since_ms)>=confirm_ms and utime.ticks_diff(now,last_switch_ms)>=hold_ms:
                gravity_dir=candidate_dir
                last_switch_ms=now

    step_once(gravity_dir)
    utime.sleep_ms(35)
```

## 5. 코드 요약

### (1) 입자와 초기 배치

```python
class Particle: ...
particles=[Particle(rand(WIDTH), -1-rand(6)) for _ in range(NUM_PARTICLES)]
```

* 하나의 픽셀을 `Particle(x,y)`로 표현합니다.
* 일부 입자는 화면 밖에서 시작해, 낙하 방향의 가장자리로 들어옵니다(지속적 유입 연출).

<br>

### (2) 빈칸 판정과 이동 벡터

```python
def is_empty(occ,x,y): ...
def primary_delta(d): ...
def diagonal_deltas(d): ...
```

* 특정 칸이 비었는지 판정하고, 현재 낙하 방향을 (dx,dy)로 변환합니다.
* 1차 이동이 실패하면 같은 방향 기준의 대각선 두 칸 중 한 칸으로 이동을 시도합니다.

<br>

### (3) 한 프레임 업데이트 `step_once(direction)`

```python
occ=[[None]*WIDTH for _ in range(HEIGHT)]
nxt=[[None]*WIDTH for _ in range(HEIGHT)]
```

* 현 상태(`occ`)와 다음 상태(`nxt`)를 분리해 동시 갱신 충돌을 방지합니다.

```python
if d=='D': y_range=range(HEIGHT-1,-1,-1)
elif d=='U': y_range=range(HEIGHT)
elif d=='L': y_range=range(HEIGHT-1,-1,-1)
else: y_range=range(HEIGHT-1,-1,-1); x_range=range(WIDTH-1,-1,-1)
```

* 순회 순서를 방향에 맞춰 바꿔, 이미 이동한 입자와의 간섭을 줄입니다.

```python
nx,ny=x+dx,y+dy
if is_empty(occ,nx,ny) and nxt[ny][nx] is None:
    nxt[ny][nx]=i
else:
    for sdx,sdy in diagonal_deltas(d):
        nx2,ny2=x+sdx,y+sdy
        if is_empty(occ,nx2,ny2) and nxt[ny2][nx2] is None:
            nxt[ny2][nx2]=i
            break
```

* 1차 이동 → 대각 이동 → 정지 순으로 처리해 흘러내리고 쌓이는 모양을 만듭니다.

```python
t=entry_target(d,p)
if t and nxt[ty][tx] is None:
    nxt[ty][tx]=idx
    p.x,p.y=tx,ty
```

* 화면 밖 입자는 낙하 방향의 가장자리에서 등장해 흐름을 유지합니다.

```python
matrix[x,y]=BACKGROUND_COLOR
matrix[x,y]=SAND_COLOR
matrix.update()
```

* 다음 상태(`nxt`)만 표시합니다. 프레임마다 전체 갱신으로 깔끔한 화면을 유지합니다.

<br>

### (4) 방향 결정과 전환 안정화

```python
ema_x=(1-ema_alpha)*ema_x+ema_alpha*gx
ema_y=(1-ema_alpha)*ema_y+ema_alpha*gy
dx=gx-ema_x; dy=gy-ema_y
```

* 지수평활(EMA)로 흔들림을 줄이고 순간 변화량을 사용합니다.

```python
if ax<tilt_threshold and ay<tilt_threshold: desired=None
else: desired='U' if ax>=ay and dx>0 else ('D' if ax>=ay else ('L' if dy>0 else 'R'))
```

* 더 큰 축과 부호로 낙하 방향 후보를 결정합니다.

```python
if utime.ticks_diff(now,candidate_since_ms)>=confirm_ms and utime.ticks_diff(now,last_switch_ms)>=hold_ms:
    gravity_dir=candidate_dir
```

* 같은 방향이 일정 시간 유지되어야만 실제 전환됩니다(튀는 전환 방지).

## 6. 결과 확인

기기를 기울이면 픽셀이 해당 방향으로 이동·쌓입니다. 방향을 바꾸면 모래가 새 방향으로 흘러가며, 가장자리에서 입자가 계속 유입되어 화면이 살아있게 보입니다.

## 7. 연습문제

1. `SAND_COLOR`를 바꿔 다른 테마(눈, 물방울 등)를 연출해 보세요.
2. `NUM_PARTICLES`를 30/80 등으로 바꿔 밀도 차이를 비교해 보세요.
3. 현재 이 코드는 Gyro 값만을 기반으로 하여 불안정한 값을 가지고 있습니다. Gyro 및 Accel 값을 구하여 Quternion 값을 구해 좀 더 정밀하게 중력 방향을 파악해 프로젝트의 완성도를 높여보세요.
