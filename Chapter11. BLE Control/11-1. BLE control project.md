# PBL 실습형 교재 문서 (Pico 단독 제어형)

## 1. 실습 주제

커스텀 UUID 기반 명령으로 **Bluetooth 스피커(앰프) 원격 제어** 만들기

## 2. 프로젝트 개요

Pico 보드가 자체적으로 광고(Advertise)하고, 연결된 중앙장치(스마트폰 등)로부터 **문자 명령**을 받아 앰프의 기능(볼륨 업/다운, 다음/이전 트랙)을 실행합니다.
명령을 처리한 뒤에는 응답(ACK/NACK)을 특성 값으로 갱신하고 알림(Notify)로 보내, 중앙장치가 결과를 즉시 확인할 수 있게 합니다.

## 3. 선행 작업

(여기에 펌웨어/패키지 설치, 스마트폰 앱 준비, 연결 테스트 절차 등을 적어 넣으세요.)

## 4. 개념 설명 (BLE 개념 제외)

* **명령 처리 흐름**: 중앙장치가 텍스트(예: `"up"`, `"down"`)를 쓰면, 보드는 이를 소문자/공백 제거 후 해석합니다.
  매칭되는 기능을 실행하고, 실행 결과를 `"ACK:<cmd>"` 형태로 작성해 동일 특성에 기록합니다.
* **결과 전달**: 최근 연결된 모든 중앙장치에 **알림(Notify)** 를 보내, 응답 문자열을 즉시 전달합니다.
* **연결/해제 상태 관리**: 연결 이벤트에 따라 연결 집합을 업데이트하고, 해제 시에는 자동으로 재광고를 시작합니다.

## 5. Pico 코드

```python
import ubluetooth as bt
import utime, struct
from btaudioamp import BtAudioAmp

_IRQ_CENTRAL_CONNECT=1
_IRQ_CENTRAL_DISCONNECT=2
_IRQ_GATTS_WRITE=3

SVC_UUID=bt.UUID('6E400001-B5A3-F393-E0A9-E50E24DCCA9E')
CHAR_UUID=bt.UUID('6E400002-B5A3-F393-E0A9-E50E24DCCA9E')
FLAGS=bt.FLAG_READ|bt.FLAG_WRITE|bt.FLAG_NOTIFY

ble=bt.BLE()
ble.active(True)

((CHAR_H,),)=ble.gatts_register_services(((SVC_UUID,((CHAR_UUID,FLAGS),)),))

amp=BtAudioAmp(4,5,6,7)

def adv_start():
    adv=bytearray()
    adv+=struct.pack('BB',2,0x01)+b'\x06'
    name=b'Pico-CTL'
    adv+=struct.pack('BB',len(name)+1,0x09)+name
    ble.gap_advertise(100_000, adv_data=adv)

conns=set()

def handle_cmd(cmd):
    if cmd=='up': amp.up(); return b'ACK:up'
    if cmd=='down': amp.down(); return b'ACK:down'
    if cmd=='next': amp.next(); return b'ACK:next'
    if cmd=='prev': amp.prev(); return b'ACK:prev'
    return b'NACK'

def irq(e,d):
    if e==_IRQ_CENTRAL_CONNECT:
        conns.add(d[0])
    elif e==_IRQ_CENTRAL_DISCONNECT:
        conns.discard(d[0]); adv_start()
    elif e==_IRQ_GATTS_WRITE and d[1]==CHAR_H and conns:
        v=ble.gatts_read(CHAR_H)
        try:
            s=v.decode().strip().lower()
        except:
            s=''
        resp=handle_cmd(s)
        ble.gatts_write(CHAR_H, resp)
        for c in tuple(conns):
            try:
                ble.gatts_notify(c, CHAR_H)
            except:
                pass

ble.irq(irq)
adv_start()

while True:
    utime.sleep_ms(100)
```

## 6. 코드 요약 (Pico)

### 6-1) 서비스·특성 등록과 광고 시작

```python
SVC_UUID=bt.UUID('...0001...')
CHAR_UUID=bt.UUID('...0002...')
FLAGS=bt.FLAG_READ|bt.FLAG_WRITE|bt.FLAG_NOTIFY
((CHAR_H,),)=ble.gatts_register_services(((SVC_UUID,((CHAR_UUID,FLAGS),)),))
```

* 한 개의 서비스와 한 개의 특성을 등록합니다.
  특성은 **읽기/쓰기/알림**을 모두 허용합니다.
* `adv_start()`에서 장치 이름(`Pico-CTL`)을 포함한 광고 패킷을 구성해 주기적으로 송출합니다.

### 6-2) 연결 상태 관리

```python
conns=set()
def irq(e,d):
    if e==_IRQ_CENTRAL_CONNECT:   conns.add(d[0])
    elif e==_IRQ_CENTRAL_DISCONNECT:
        conns.discard(d[0]); adv_start()
```

* 연결되면 연결 핸들을 집합에 저장합니다.
* 해제되면 집합에서 제거하고 **즉시 재광고**를 시작합니다(다음 연결 대기).

### 6-3) 명령 수신 → 앰프 제어 → 응답 전송

```python
elif e==_IRQ_GATTS_WRITE and d[1]==CHAR_H and conns:
    v=ble.gatts_read(CHAR_H)
    s=v.decode().strip().lower()  # 예: "up", "down"
    resp=handle_cmd(s)            # 실행 후 응답 바이트 반환
    ble.gatts_write(CHAR_H, resp) # 응답을 특성 값에 기록
    for c in tuple(conns):
        ble.gatts_notify(c, CHAR_H)  # 모든 연결 대상에게 알림
```

* 중앙장치가 특성에 문자열을 **쓰기** 하면, 그 값을 읽어 공백 제거·소문자로 정규화합니다.
* `handle_cmd()`가 해당 문자열을 해석해 **앰프 제어 함수**를 호출하고,
  성공 시 `b"ACK:<cmd>"`, 미지원 명령 시 `b"NACK"`을 반환합니다.
* 응답을 특성에 기록하고, **알림(Notify)** 로 즉시 전송합니다.

### 6-4) 앰프 제어 명령 매핑

```python
def handle_cmd(cmd):
    if cmd=='up': amp.up();   return b'ACK:up'
    if cmd=='down': amp.down(); return b'ACK:down'
    if cmd=='next': amp.next(); return b'ACK:next'
    if cmd=='prev': amp.prev(); return b'ACK:prev'
    return b'NACK'
```

* 지원 명령: `up`, `down`, `next`, `prev`
* 각 명령은 `BtAudioAmp` 의 대응 메서드를 호출합니다.

## 7. 결과 확인

* 스마트폰/PC의 BLE GATT 도구에서 장치 **Pico-CTL**에 연결합니다.
* 특성에 `"up"`, `"down"`, `"next"`, `"prev"` 중 하나를 **Write** 하면, 스피커가 동작하고 특성 값이 `ACK:*` 으로 갱신됩니다.
* Notify 수신이 설정되어 있으면 응답이 즉시 표시됩니다.

📸 **사진/스크린샷 삽입 위치 (앱 화면, 장치 리스트, 명령 결과, 스피커 작동 장면)**
(여기에 실제 연결 화면, 특성 Write/Notify 로그, 스피커 반응 사진을 첨부하세요.)

## 8. 연습문제

1. 지원 명령에 `"mute"` / `"play"` / `"pause"` 를 추가해 보세요.
2. 잘못된 명령이 연속 입력되면 `b"NACK:<cmd>"` 처럼 **원인 포함 응답**을 보내도록 바꿔 보세요.
3. 응답을 누적 로그(길이 제한 포함)로 유지하고, 중앙장치가 Read 할 때 최근 N개를 확인할 수 있게 확장해 보세요.
